[
{
	"uri": "/tuto-asm-01/01/01introduction/",
	"title": "01-Introduction",
	"tags": [],
	"description": "",
	"content": " Outils nécessaires:  Tiasm (assembleur) blueMSX (émulateur) Context Editor (éditeur de texte)  Le but de ce blog est de présenter le plus simplement possible l\u0026rsquo;utilisation de l\u0026rsquo;assembleur sur MSX. Quitte à vulgariser, je tente de regrouper ici, ce que je n\u0026rsquo;ai pu trouver ailleurs sur le net afin de m\u0026rsquo;initier à l\u0026rsquo;assembleur.\nJe me suis procuré le livre suivant : MSX Programmes en langage machine de Steve WEBB. Ce livre contient notamment un programme réalisé en assembleur. C\u0026rsquo;est un shoot-em-up très basique mais qui permet de mettre en application les notions de base de l\u0026rsquo;assembleur.\nLes articles de ce site vont décrire, par étapes, les notions abordées et la manière dont je les ai comprises\n"
},
{
	"uri": "/tuto-asm-01/02/02structure/",
	"title": "02-Structure",
	"tags": [],
	"description": "",
	"content": " Je vais présenter uniquement ce qui est utile pour débuter le programme assembleur.\nLe MSX c\u0026rsquo;est un processeur Z80 (le coeur). Il discute avec 3 organes principaux :\n Le VDP : Un processeur qui gère l\u0026rsquo;affichage écran (16ko de mémoire).\n Le PSG : Un processeur qui gère le son.\n Le PPI : Un processeur qui gère le clavier notamment.  Revenons au Z80, il dispose de 3 sortes de mémoires :\n La ROM.\n La RAM.\n Les registres internes.  Les mémoires sont des cases. Pour pouvoir les différencier, on leur a donné des numéros que l\u0026rsquo;on appelle Adresse (comme les numéros des maisons dans une rue).\n Ces adresses vont de 0 à 65535.\n Chaque adresse peut contenir un nombre entre 0 et 255.  ROM Appelée mémoire morte. On peut simplement lire cette mémoire.\nOn ne peut pas la modifier (données constructeur).\nElle contient de petits programmes (routines) bien pratiques que l\u0026rsquo;on utilisera en assembleur pour lancer des actions ou faire des calculs.\nRAM Appelée mémoire vive. Elle est modifiable et c\u0026rsquo;est celle que nous utiliserons pour programmer. Par contre elle s\u0026rsquo;efface dès que l\u0026rsquo;on éteint le MSX. C\u0026rsquo;est pour cela que l\u0026rsquo;on sauvegarde nos programmes.\nRegistres internes Ce sont des sortes de mémoires. Ils n\u0026rsquo;ont pas d\u0026rsquo;adresse mais des lettres. En assembleur, c\u0026rsquo;est avec eux (une vingtaine environ) que l\u0026rsquo;on va jouer. On va rappeler des adresses, lire ou écrire dedans et faire des calculs. Et tout ça, c\u0026rsquo;est avec l\u0026rsquo;aide de ces registres que l\u0026rsquo;on va le faire.\nIl existe une page très simple et explicative du fonctionnement de ces registres du Z80 : Wiki Z80\nIl est important que l\u0026rsquo;on parle du VDP pour finir car c\u0026rsquo;est avec lui que l\u0026rsquo;on va discuter fréquemment pour afficher nos sprites et les faire bouger. Je passe volontairement sur les autres processeurs (PSG et PPI), on y reviendra au besoin.\nVDP Ce processeur permet d\u0026rsquo;afficher des images, des caractères ou des sprites à l\u0026rsquo;écran. Il contient 16ko de mémoire, appelée VRAM (dans laquelle on peut lire et écrire) et 9 registres internes (R0 à R7+ 1 registre d\u0026rsquo;état) qui ne sont pas les mêmes que ceux du Z80. La VRAM est divisée en 5 tables : 3 pour gérer l\u0026rsquo;affichage des caractères et 2 pour les sprites. Ces tables ne sont rien d\u0026rsquo;autre qu\u0026rsquo;un groupe d\u0026rsquo;adresses pouvant stocker des nombres. Les 3 tables des caractères:\n- TGP (Table Génératrice des Patrons): C\u0026rsquo;est là que l\u0026rsquo;on stocke les formes des caractères. Quand on tape la lettre A, le processeur Z80 demande au VDP de choisir la forme correspondant à la lettre A dans cette table.\n- TNP (Table des Noms des Patrons): C\u0026rsquo;est là que l\u0026rsquo;on va indiquer où afficher le caractère à l\u0026rsquo;écran.\n- TC (Table des Couleurs): C\u0026rsquo;est dans cette table que l\u0026rsquo;on va choisir la couleur du caractère et du fond de ce caractère.\n\rLe principe de fonctionnement de ces 3 tables est le suivant : on demande au processeur VDP d\u0026rsquo;afficher un (ou des) caractère(s) en définissant ce que l\u0026rsquo;on veut afficher, où on veut l\u0026rsquo;afficher et dans quelle couleur. Et comme on connait maintenant les tables de caractères, on pourra modifier la forme de ces derniers à volonté (par exemple pour dessiner un décor de jeu).\nLes 2 tables des sprites:\n-TGS (Table Génératrice des Sprites): Stocke les dessins des sprites que l\u0026rsquo;on va définir.\n-TAS (Table des Attributs des Sprites): stocke la position, le numéro et la couleur de chaque sprite.\n\rChacune de ces 5 tables débute par une adresse que l\u0026rsquo;on doit connaitre pour pouvoir y intégrer une liste d\u0026rsquo;informations, qui seront stockées à partir de là, vers les adresses suivantes en fonction du nombre d\u0026rsquo;informations (données) à stocker.\nPour définir automatiquement ces adresses de début en suivant les données constructeur, le VDP utilise 4 modes de fonctionnement :\n SCREEN 0 : Le mode texte\n SCREEN 1 : Le mode graphique 1\n SCREEN 2 : Le mode graphique 2\n SCREEN 3 : Le mode multicolore  Le programme assembleur que je veux expliquer utilise le SCREEN 1 donc je ne parlerai que de celui-là pour l\u0026rsquo;instant.\nLe SCREEN 1 sur MSX1 c\u0026rsquo;est 32 colonnes sur 24 lignes de texte et la possibilité d\u0026rsquo;utiliser les sprites.\n"
},
{
	"uri": "/tuto-asm-01/03/03affchr/",
	"title": "03-Afficher un caractère",
	"tags": [],
	"description": "",
	"content": " (La théorie) Un caractère affiché par le VDP c\u0026rsquo;est 3 tables auxquelles on devra donner des instructions:\n TNP (position à l\u0026rsquo;écran)\n TGP (la forme du caractère)\n TC (la couleur du caractère et du fond de celui-ci)\n  TNP  En mode SCREEN 1, on a vu que la TNP débute à l\u0026rsquo;adresse 6144.\n On sait aussi qu\u0026rsquo;en SCREEN 1 on a 32 colonnes pour 24 lignes (pour le texte). Cela donne 768 positions possibles à l\u0026rsquo;écran (32 x 24 = 768).\nCes positions vont de gauche à droite (comme le fonctionnement d\u0026rsquo;une machine à écrire), de la position 0 à 31 pour la première ligne, puis passe à la ligne 2 et poursuit la numérotation jusqu\u0026rsquo;à la dernière position N° 768 en bas à droite.\nVoici l\u0026rsquo;écran telle qu\u0026rsquo;il est en SCREEN 1 :  TNP Screen 1 \nToutes les positions sont des adresses mémoires qui se suivent. Sachant que la TNP débute à l\u0026rsquo;adresse 6144, on sait maintenant que cette adresse correspond à la position 0. Si on veut afficher le caractère à la position 5, on va simplement faire 6144+5 et on aura l\u0026rsquo;adresse où afficher le caractère: 6149\nTGP On a vu que c\u0026rsquo;était la table qui abrite les formes des caractères. Cette table contient 256 caractères numérotés sous la norme standard internationale ASCII.\n Table des caractères \nUn exemple avec le tableau ci-dessus :\nVous voulez le code ASCII de la lettre \u0026lsquo;A\u0026rsquo;, vous prenez le N° de ligne et de colonne (respectivement), ici 4 et 1, vous l\u0026rsquo;assemblez et cela donne du hexadécimal : 41\nEn assemblage on utilise beaucoup l\u0026rsquo;hexadécimal pour des raisons que je n\u0026rsquo;expliquerai pas ici.\nMais il est facile de traduire de l\u0026rsquo;hexadécimal vers le décimal (et inversement), avec une calculatrice.\nCelle de Windows le fait très bien, il suffit de choisir dans le menu : Affichage/Programmeur.\nVous cochez : Vous rentrez le nombre 41, il ne vous reste plus qu\u0026rsquo;à cocher\nDéc  et vous obtenez du décimal, dans notre cas 65, qui est le n° ASCII de la lettre \u0026lsquo;A\u0026rsquo; que reconnait la TGP, ouf !!!\nJuste pour information, l\u0026rsquo;adresse de la lettre \u0026lsquo;A\u0026rsquo; dans la TGP n\u0026rsquo;est pas 65. Chaque caractère est défini dans une grille de 8 x 8 (comme un sprite simple).\nDonc chaque caractère prend 8 adresses mémoires successives dans la TGP.\nLa TGP débute en 0 (SCREEN 1), notre \u0026lsquo;A\u0026rsquo; est le 65ème, donc son adresse de début de forme est : Adresse de début de la TGP + 65*8 = 0 + 520 = 520\nSi on voulait modifier la forme du \u0026lsquo;A\u0026rsquo; il faudrait que l\u0026rsquo;on modifie les valeurs des adresses 520 à 527 (8 octets), mais on va pas le faire dans notre exemple.\nAvec l\u0026rsquo;adresse et le code du caractère, on est déjà capable de l\u0026rsquo;afficher, la couleur est optionnelle. On va quand même voir comment la TC fonctionne.\nTC Pour modifier cette table, il nous faut 2 informations :\nL\u0026rsquo;adresse du caractère dans cette table. Le calcul de sa couleur.  Dans notre exemple, le \u0026lsquo;A\u0026rsquo; c\u0026rsquo;est le numéro 65, on le divise par 8 et on ajoute ce résultat au début de l\u0026rsquo;adresse de la table (8192 en SCREEN1). (65:8) + 8192 = 8200 (on ne retient que la part entière).\n 8200 c\u0026rsquo;est l\u0026rsquo;adresse du \u0026lsquo;A\u0026rsquo; dans la TC.\n Pour la couleur (16 couleurs disponibles en SCREEN 1), le calcul est :\nCouleur du caractère x 16 + couleur de fond du caractère. Pour un caractère Magenta (couleur 13) et Fond Blanc (couleur 15) cela donne:\n13 x 16 + 15 = 223\nDonc si on veut modifier une couleur, on passe par cette table et on modifie la valeur de l\u0026rsquo;adresse 8200 en lui mettant 223. Affiche le caractère \u0026lsquo;A\u0026rsquo; à l\u0026rsquo;écran\nVoilà, on va mettre tout cela en application en utilisant enfin un assembleur pour MSX.\nL\u0026rsquo;article suivant va uniquement parler de la mise en place des outils pour programmer en assembleur.\nC\u0026rsquo;est le préalable à la mise en pratique de ce que nous avons vu jusqu\u0026rsquo;ici.\n"
},
{
	"uri": "/tuto-asm-01/04/04-mise-en-place/",
	"title": "04-Mise en place",
	"tags": [],
	"description": "",
	"content": " des outils de développement On va avoir besoin d\u0026rsquo;installer 3 programmes :\n Un émulateur (simule un MSX)\n Un éditeur de texte (pour taper du code texte assembleur)\n un assembleur (compile le code texte en code machine utilisable par un MSX)  Pour cela j\u0026rsquo;ai suivi les explications du site d\u0026rsquo;un développeur anglais dont je vous donne l\u0026rsquo;adresse de sa chaine Youtube :\nLets Make a Retro Game\nEMULATEUR L\u0026rsquo;émulateur MSX s\u0026rsquo;appelle blueMSX, je vous invite à le télécharger à l\u0026rsquo;adresse suivante dans la section téléchargement : http://www.bluemsx.com\nVous l\u0026rsquo;installez où vous voulez, il n\u0026rsquo;y a rien de particulier.\nQuand vous le lancez pour la première fois, je vous invite à aller dans le le menu, choisir Outils, ensuite Editeur de machine et dans le champ Configuration vous sélectionnez MSX-French et vous cliquez sur le bouton [Lancer].\nVous avez un MSX francais qui démarre,vous validez par [Entrée] quand il vous demande la date.\nEDITEUR DE TEXTE On va installer un éditeur de texte qui s\u0026rsquo;appelle CONTEXT Editor, il est simple d\u0026rsquo;utilisation et permettra de lancer la compilation avec des touches de raccourci.\nLe liens de téléchargement est le suivant :\nCONTEXT Editor\nInstallez en suivant la procédure proposée par défaut.\nLe développeur du site que j\u0026rsquo;ai indiqué nous met à disposition un petit plugin qui permet de mettre en couleur le texte assembleur, il se trouve ici : coloration de syntaxe\nPour ajouter le colorateur syntaxique à CONTEXT il faut coller le fichier WLA DX Z80 Assembler.chl dans le dossier suivant :\nC:\\Program Files (x86)\\ConTEXT\\Highlighters Le dossier sera le suivant si vous êtes en mode Windows 32-bit :\nC:\\Program Files\\ConTEXT\\Highlighters\nASSEMBLEUR Pour l\u0026rsquo;assembleur, c\u0026rsquo;est tniASM (v0.45).\nIl est simple et pratique lui aussi.\nVoici l\u0026rsquo;adresse : tniasm 0.45\nVous téléchargez la version gratuite et vous la dézippez dans le répertoire suivant sur votre PC :\nC:\\tniasm045\nVous devez ainsi avoir les 2 fichiers suivant dans le dossier \u0026lsquo;tniasm045\u0026rsquo; :\n tniasm.exe\n tniasm.txt  Le fichier tniasm.txt est la documentation de l\u0026rsquo;outil, mais en anglais. Vu que je me suis \u0026lsquo;cogné\u0026rsquo; la traduction en français, autant qu\u0026rsquo;elle serve : doc française de tniasm à télécharger en bas de cette page.\nCONTEXT-TOUCHE RACCOURCI Afin de rendre CONTEXT plus facile d\u0026rsquo;utilisation, on peut paramétrer des touches de raccourci pour compiler le code automatiquement, et faire apparaître les lignes d\u0026rsquo;erreur.\nDans le menu de CONTEXT choisissez \u0026lsquo;Options / Environment Options / Execute Keys vous devez avoir cet écran :\nCliquez sur le bouton [Add] et remplissez avec asm,z80 Ainsi, on va définir une action pour tous les fichiers qui ont une extension de type .asm ou .z80.\nCliquez sur [OK]. Vous devriez obtenir cela dans la petite fenêtre de gauche :\nCliquez sur la touche de fonction F9 dans cette petite fenêtre et ensuite remplissez les champs à droite comme suit :\n   champs Valeur à taper     Execute c:\\tniasm045\\tniasm.exe   Start in %p   Parameters %n   Window Normal   Hint Compile   Save Current file before execution   Use short Dos names Not ticked   Capture console output Ticked   Compiler output parser rule *line%l(%n)*   Scroll console to the last line Ticked    Vous obtenez ceci :\nQuand on voudra compiler du code assembleur, on aura plus qu\u0026rsquo;à appuyer sur F9 et cela se fera automatiquement, ou s\u0026rsquo;il y a une erreur de compilation on le verra dans la fenêtre basse de CONTEXT.\nPour tester cet environnement on utilisera des fichiers source, c\u0026rsquo;est l\u0026rsquo;objet du prochain article.\nJe tiens à remercier celui qui a fait cette procédure d\u0026rsquo;installation, que je n\u0026rsquo;ai fait que traduire et adapter à notre exemple, visitez son site : http://www.electricadventures.net/\n\r\r\rFichiers associés\r\r\rtniasm_fr.txt\r\r(29 ko)\r\r\r\r"
},
{
	"uri": "/tuto-asm-01/05/05-decouverte/",
	"title": "05-Découverte du code",
	"tags": [],
	"description": "",
	"content": " Fichiers sources et découverte du code assembleur MSX Pour faire fonctionner l\u0026rsquo;environnement que l\u0026rsquo;on a mis en place, on a besoin d\u0026rsquo;un document où taper notre code.\nIl se présente sous la forme d\u0026rsquo;un petit fichier texte comme on peu en utiliser avec le blocnote de Windows. Sauf que le notre aura une extension de fichier qui se termine par .asm au lieu du traditionnel .txt\nC\u0026rsquo;est lui que l\u0026rsquo;on va ouvrir avec l\u0026rsquo;éditeur de texte CONTEXT, c\u0026rsquo;est lui qui va recevoir le code que l\u0026rsquo;on va taper et c\u0026rsquo;est encore lui que l\u0026rsquo;on va compiler via la touche de fonction F9. Cette compilation nous donnera un fichier exploitable par l\u0026rsquo;émulateur MSX.\nCe fichier ne peut pas être compilé tout seul, il a besoin de se trouver dans le même dossier ou vont figurer 2 fichiers sources (appelées librairies) et qui aideront à la compilation.\nEn effet notre fichier principal comporte un entête et un pied de page que l\u0026rsquo;on ne touchera pas mais qui à l\u0026rsquo;aide des librairies feront qu\u0026rsquo;à la compilation on se retrouvera avec un fichier de sortie qui aura l\u0026rsquo;extension .ROM.\nEt miracle, cela simulera les fameuses cartouches ROM de notre enfance qui démarraient automatiquement quand on allumait notre bon vieux MSX.\nCe fichier ne peut pas être compilé tout seul, il a besoin de se trouver dans le même dossier ou vont figurer 2 fichiers sources (appelées librairies) et qui aideront à la compilation. En effet notre fichier principal comporte un entête et un pied de page que l\u0026rsquo;on ne touchera pas mais qui à l\u0026rsquo;aide des librairies feront qu\u0026rsquo;à la compilation on se retrouvera avec un fichier de sortie qui aura l\u0026rsquo;extension.ROM. Et miracle, cela simulera les fameuses cartouches ROM de notre enfance qui démarraient automatiquement quand on allumait notre bon vieux MSX.\nBon on résume avec un schéma :\nBon, j\u0026rsquo;espère que c\u0026rsquo;est plus clair maintenant.\nAvant que je ne vous donne le liens de téléchargement des fichiers sources, je vais vous les présenter:\nLe fichier principal, celui où on tapera notre code (pour l\u0026rsquo;instant, il n\u0026rsquo;y a que l\u0026rsquo;entête et le pied de page à l\u0026rsquo;intérieur) :\nexample.asm  Les 2 librairies, qui doivent se trouver toujours dans le même dossier que le fichier principal sinon l\u0026rsquo;assembleur ne saura pas où les trouver :\nMSXRom-Include.asm MSXRom-Lib.asm  Pour le lien du dossier : fichiers source à télécharger en bas de cette page. Je me dois encore remercier celui qui a fourni ces sources, c\u0026rsquo;est son travail : http://www.electricadventures.net/\n\rVous ouvrez exemple.asm avec CONTEXT et on va en profiter pour utiliser le colorateur syntaxique qui reconnait le langage assembleur et que l\u0026rsquo;on a téléchargé précédemment.\nDonc, dans le menu de CONTEXT, choisissez Tools / Set Highlighter et dansla liste des codes connus, vous devez trouver WLA-Z80 Assembler, sélectionnez-le.\nSi vous voulez faire apparaître les numéros de ligne sous CONTEXT (utile pour le debuggage), dans le menu de CONTEXT, choisissez Options / Environment Options / onglet Editor et vous cochez Line numbers.\nVous devez en être là :\n2 fenêtres:\n La partie haute : zone où on tape le code. La partie basse : zone de suivi de la compilation quand on fait F9.  Regardons ce code depuis le début :\n; **************************************************************** ; MSX ROM Cartridge Header and Function library ; **************************************************************** FNAME \"exemple.ROM\" cpu z80 ORG 4000h INCLUDE \"MSXRom-Include.asm\" db \"AB\" DW INIT ; la ROM lance le sous-programme INIT au démarrage DW 0 DW 0 DW 0 DS 6  C\u0026rsquo;est ce que j\u0026rsquo;appelle l\u0026rsquo;entête.\nFNAME: c\u0026rsquo;est le nom du fichier qui sortira à la compilation, vous pouvez donc mettre le nom que vous voulez entre les \u0026ldquo; \u0026rdquo; du moment que vous conservez l\u0026rsquo;extension.ROM.\ncpu Z80: La compilation utilisera la librairie Z80 (tniASM en gère plusieurs).\nORG 4000h: Notre programme s\u0026rsquo;implantera à cette adresse au démarrage de la ROM dans l\u0026rsquo;émulateur. Pour info, quand un nombre est suivi de \u0026lsquo;h\u0026rsquo; c\u0026rsquo;est que l\u0026rsquo;on indique que c\u0026rsquo;est un Hexadécimal sinon, c\u0026rsquo;est un décimal.\nINCLUDE: C\u0026rsquo;est pour cela que je vous disais que les librairies doivent être dans le même dossier, car à la compilation, tniASM va chercher tous les fichiers cité par in INCLUDE et qui va lui permettre d\u0026rsquo;interpréter le code spécifique à l\u0026rsquo;assembleur MSX.\nDW INIT: Cette suite de DW permet de créer une structure de ROM à la compilation d\u0026rsquo;après ce que j\u0026rsquo;en ai compris. Ce qui est important, c\u0026rsquo;est le mot INIT, cela aurait pu être n\u0026rsquo;importe quoi FRAISE, MARTEAU,etc\u0026hellip;\nCela intime l\u0026rsquo;ordre au démarrage de la ROM d\u0026rsquo;aller déclencher le code qui commence par ce \u0026lsquo;label\u0026rsquo;. Ces \u0026lsquo;labels\u0026rsquo; sont des bout de programmes appelés routines qui que l\u0026rsquo;on pourra appeler au besoin. En effet, en assembleur, on ne dispose pas des lignes comme en BASIC alors on appelle des \u0026lsquo;labels\u0026rsquo; pour sauter à une partie du programme.\nLe pied de page est présenté ici mais je n\u0026rsquo;en parlerai pas, il ne vous apprendra rien de plus : En fait, je ne le maîtrise pas, alors je le laisse ;-)\nPour info, lorsque on tape un point virgule ; ce qui suis sur la ligne est du commentaire et ne sera pas interprété comme du code par l\u0026rsquo;assembleur.\n;************************************************************************************************** ; Standard Libraries ;************************************************************************************************** INCLUDE \"MSXRom-Lib.asm\" ; intègre la librairie MSX END: EQU $ ;************************************************************************************************** ; RAM Definitions ;************************************************************************************************** ;------------------- ; Définit que le programme démarrera au début de la RAM disponible ;------------------- ORG RAMSTART  Ce qui nous intéresse se trouve entre ces 2 parties :\n;------------------------------------------------------------------------------ ; Démarrage du programme à INIT ;------------------------------------------------------------------------------ INIT: ; Tapez votre code à partir d'ici  C\u0026rsquo;est ici que nous allons taper notre 1er code\u0026hellip;.dans le prochain article.\n\r\rFichiers associés\r\r\rsources.zip\r\r(5 ko)\r\r\r\r"
},
{
	"uri": "/tuto-asm-01/06/06-afficher_chr/",
	"title": "06-La pratique",
	"tags": [],
	"description": "",
	"content": " La pratique : Afficher un caractère On va maintenant taper notre 1er code qui permettra :\n  Activer le mode SCREEN 1. Afficher le caractère A à la position 5 de l\u0026rsquo;écran. Changer la couleur du caractère et du fond du caractère. Faire une boucle infinie pour que le résultat de cet affichage reste à l\u0026rsquo;écran.   Voici ce que cela donne pour l\u0026rsquo;ensemble du code, mais on va le reprendre bout par bout :\n;------------------------------------------------------------------------------ ; Démarrage du programme à INIT ;------------------------------------------------------------------------------ INIT: Ld a,1 ; 1 pour 'SCREEN 1' ld [64687],a ; routine BIOS [SCRMOD] : mode courant de l'écran call 95 ; routine BIOS [CHMOD] : change le mode l'écran ld a,65 ; on charge l'accumulateur avec 65 (ASCII de 'A') ld hl,6144+5 ; on charge en HL l'adresse de la TNP + 5 (position 5) call 77 ; routine BIOS [WRTVRM] : écrit dans la VRAM (write to VRAM) ld a,223 ; on charge le code couleur (magenta sur blanc=223) ld hl,8200 ; on charge l'adresse de la TC pour le caractère 'A' call 77 ; routine BIOS [WRTVRM] : écrit dans la VRAM (write to VRAM) BOUCLE: ; A la fin d'INIT, le programme n'est pas stoppé alors il continue JP BOUCLE ; dans le prochain label, ici BOUCLE (comparable à 100 GOTO 100)  C\u0026rsquo;est parti :\nEn mode assembleur, en général, on charge un accumulateur A avec une valeur entre 0 et 255, et une adresse en HL (ce sont les registres internes avec lesquels la RAM fait les calculs) puis on lance l\u0026rsquo;odre d\u0026rsquo;exécution par un CALL.\nSCREEN 1 C\u0026rsquo;est l\u0026rsquo;exemple type, l\u0026rsquo;adresse 64687 est une routine BIOS qui abrite le mode courant de l\u0026rsquo;écran (SCREEN 1, 2 ou 3).\n Donc la 1ere ligne charge (c\u0026rsquo;est l\u0026rsquo;instruction \u0026lsquo;LD\u0026rsquo;) A avec 1 donc A=1. On assigne cette valeur à l\u0026rsquo;adresse 64687 (2eme ligne). Et enfin on donne l\u0026rsquo;ordre via une routine spécifique du BIOS en ROM d\u0026rsquo;exécuter cela. Après le CALL le SCREEN 1 est effectif.  ;------------------------------------------------------------------------------ ; Démarrage du programme à INIT ;------------------------------------------------------------------------------ INIT: Ld a,1 ; 1 pour 'SCREEN 1' ld [64687],a ; routine BIOS [SCRMOD] : mode courant de l'écran call 95 ; routine BIOS [CHMOD] : change le mode l'écran  Au départ ces adresses et routines appelées semblent obscures mais celles que l\u0026rsquo;on utilise régulièrement sont en nombre réduit et deviendront familières rapidement. J\u0026rsquo;utilise souvent le décimal, mais CALL 95 peut s\u0026rsquo;écrire aussi CALL $5F en hexadécimal, tniasm reconnait la plupart des expressions pour l\u0026rsquo;hexadécimal (voir sa doc).\nUn site pour voir la liste des routines BIOS : http://map.grauw.nl/resources/msxbios.php\n CHGMOD\nAddress : #005F\nFunction : Switches to given screenmode\nInput : A - screen mode\nRegisters: All\n AFFICHAGE DU \u0026lsquo;A\u0026rsquo; Là, ça doit vous parler, on connait la valeur du caractère \u0026lsquo;A\u0026rsquo; en ASCII = 65.\nOn a vu dans la théorie que le début de la table TNP (qui gère les positions d\u0026rsquo;affichage) est à l\u0026rsquo;adresse 6144 en SCREEN 1. On a choisit arbitrairement la position 5 (vous pouvez vous amuser avec une autre valeur).\nPetite nouveauté, le CALL 77 (CALL $4D) qui exécute l\u0026rsquo;ordre du calcul que l\u0026rsquo;on vient de faire attend A et HL chargés en entrants :\n WRTVRM\nAddress : #004D\nFunction : Writes data in VRAM\nInput : HL - address write\nA - value write\n Voici le bout de code correspondant :\nld a,65 ; on charge l\u0026rsquo;accumulateur avec 65 (ASCII de \u0026lsquo;A\u0026rsquo;) ld hl,6144+5 ; on charge en HL l\u0026rsquo;adresse de la TNP + 5 (position 5) call 77 ; routine BIOS [WRTVRM] : écrit dans la VRAM (write to VRAM) \nCHANGER LA COULEUR DU CARACTERE Même punition. Tout est dans le commentaire du code : ld a,223 ; on charge le code couleur (magenta sur blanc=223) ld hl,8200 ; on charge l\u0026rsquo;adresse de la TC pour le caractère \u0026lsquo;A\u0026rsquo; call 77 ; routine BIOS [WRTVRM] : écrit dans la VRAM (write to VRAM) \nBOUCLE INFINIE On se rajoute cette boucle pour ne pas revenir au BASIC et perdre l\u0026rsquo;affichage.\nBOUCLE: ; A la fin d\u0026rsquo;INIT, le programme n\u0026rsquo;est pas stoppé alors il continue JP BOUCLE ; dans le prochain label, ici BOUCLE (comparable à 100 GOTO 100) \nIl n\u0026rsquo;y a plus qu\u0026rsquo;a compiler et demander à l\u0026rsquo;émulateur d\u0026rsquo;utiliser le fichier généré qui doit être \u0026ldquo;testA.ROM\u0026rdquo;\u0026hellip;.vous vous souvenez, le FNAME dans l\u0026rsquo;entête, au début du code, ben je l\u0026rsquo;ai modifié ainsi pour changer le nom de fichier généré.\nCOMPILATION On clique sur la touche de fonction [F9], cela sauvegarde notre fichier texte et lance la compilation.\nVous pouvez aussi procéder autrement: Sauvegardez votre fichier et dans l\u0026rsquo;explorateur Windows, faites glissez votre \u0026ldquo;testA.asm\u0026rdquo; sur \u0026ldquo;tniasm.exe\u0026rdquo; avec la souris et cela va déclencher la compilation et créer le fichier en sortie dans le même dossier. Cela sous-entend que tniasm est dans le même dossier que votre code et ses librairies. L\u0026rsquo;inconvénient c\u0026rsquo;est que vous ne savez pas s\u0026rsquo;il y a des erreurs de compilation.\nOn voit que la fenêtre basse de CONTEXT a changée : On voit les 2 passes pour générer le fichier .ROM et pas d\u0026rsquo;erreur.\nSi vous avez une erreur, elle se présentera de cette manière :\nCONTEXT indique la ligne d\u0026rsquo;erreur, ici pour l\u0026rsquo;exemple c\u0026rsquo;est la ligne 22.\nQuand on regarde notre code, on voit que l\u0026rsquo;on a ajouté un t par erreur\u0026hellip;.c\u0026rsquo;est pas toujours aussi évident, je vous l\u0026rsquo;accorde.\nFICHIER .ROM GENERE Si tout c\u0026rsquo;est bien passé, notre répertoire où se trouve notre code doit ressembler à ceci :  Les 2 librairies\n Notre code principal : \u0026ldquo;testA.asm\u0026rdquo; Le fichier \u0026ldquo;testA.ROM\u0026rdquo; généré, c\u0026rsquo;est celui-ci qui nous intéresse.\n 3 fichiers de compilations (en surligné dans l\u0026rsquo;image ci-dessus) que l\u0026rsquo;on n\u0026rsquo;utilisera pas.\n  On va prendre le \u0026ldquo;testA.rom\u0026rdquo; et le faire glisser avec la souris dans l\u0026rsquo;émulateur blueMSX que vous aurez ouvert au préalable.\nBlueMSX va rebooter le MSX et au bout de quelques secondes on doit admirer\u0026hellip;..un caractère\u0026hellip;..mais en couleur s\u0026rsquo;il vous plait !!!\nOn voit dans le bandeau en bas que dans le champs \u0026lsquo;SCREEN\u0026rsquo; nous sommes bien passé en \u0026lsquo;SCR 1\u0026rsquo;\nEJECTER LA ROM ET QUITTER Vous vous rappelez que nous avons mis une boucle infinie à la fin de notre code, de ce fait nous ne pouvons avoir d\u0026rsquo;action sur l\u0026rsquo;émulateur et si vous le rebootez en appuyant sur le gros bouton rond en haut à gauche (à côté du point rouge), blueMSX va relancer la machine mais aussi notre fichier .ROM.\nEn effet, nous venons de créer une cartouche 16ko et elles sont faites pour démarrer automatiquement.\nDonc si vous voulez éjecter la cartouche, vous appuyez sur le bouton rond à côté de slot et choisissez Ejecter: testA.ROM :\nblueMSX va rebooter la machine automatiquement mais sans la cartouche et rendre la main à l\u0026rsquo;invite de commande du BASIC.\nLe prochain article on apprendra à afficher les sprites, pour cela on partira directement sur l\u0026rsquo;élaboration du shoot-em-up.\n"
},
{
	"uri": "/",
	"title": "Accueil",
	"tags": [],
	"description": "",
	"content": " MSX-coding Code et Documentation de l\u0026rsquo;ordinateur MSX.\n"
},
{
	"uri": "/tuto-asm-01/",
	"title": "Tuto ASM 01",
	"tags": [],
	"description": "",
	"content": " Tuto 1 ASM Pour débuter l\u0026rsquo;apprentissage de l\u0026rsquo;assembleur.\n"
},
{
	"uri": "/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]