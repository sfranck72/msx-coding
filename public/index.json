[
{
	"uri": "/tuto-asm-01/01/01introduction/",
	"title": "01-Introduction",
	"tags": [],
	"description": "",
	"content": " Outils nécessaires:  Tiasm (assembleur) blueMSX (émulateur) Context Editor (éditeur de texte)  Le but de ce blog est de présenter le plus simplement possible l\u0026rsquo;utilisation de l\u0026rsquo;assembleur sur MSX. Quitte à vulgariser, je tente de regrouper ici, ce que je n\u0026rsquo;ai pu trouver ailleurs sur le net afin de m\u0026rsquo;initier à l\u0026rsquo;assembleur.\nJe me suis procuré le livre suivant : MSX Programmes en langage machine de Steve WEBB. Ce livre contient notamment un programme réalisé en assembleur. C\u0026rsquo;est un shoot-em-up très basique mais qui permet de mettre en application les notions de base de l\u0026rsquo;assembleur.\nLes articles de ce site vont décrire, par étapes, les notions abordées et la manière dont je les ai comprises\n"
},
{
	"uri": "/dynamicpub/01/",
	"title": "Article 1",
	"tags": [],
	"description": "",
	"content": " N°01 : Utiliser une police de caractère et afficher du texte. L\u0026rsquo;article a été réalisé sur MSX à l\u0026rsquo;aide du programme Dynamic Publisher.\nArticle au format PDF :\n dynpub01.pdf  Article au format PDF :\n DynPub Fr.dsk\nLa version dsk est un format disquette pour le charger sur un émulateur MSX par exemple.  Manuel Dynamic Publisher :\n DynamicPublisher-Manuel.pdf  \r\rFichiers associés\r\r\rDynPub Fr.dsk\r\r(720 ko)\r\r\rDynamicPublisher-Manuel.pdf\r\r(8611 ko)\r\r\rdynpub01.pdf\r\r(1243 ko)\r\r\r\r"
},
{
	"uri": "/traductions/karoshi/",
	"title": "Traductions KAROSHI",
	"tags": [],
	"description": "",
	"content": " Assembleur Série sur l\u0026rsquo;intiation à l\u0026rsquo;assembleur du site KAROSHI :\n Tuto_01.pdf\n Tuto_03.pdf\n Tuto_04.pdf\n Tuto_04.pdf  \r\rFichiers associés\r\r\rTuto_01.pdf\r\r(1813 ko)\r\r\rTuto_03.pdf\r\r(1443 ko)\r\r\rTuto_04.pdf\r\r(833 ko)\r\r\rTuto_05.pdf\r\r(1712 ko)\r\r\r\r"
},
{
	"uri": "/tuto-asm-01/",
	"title": "Tuto ASM 01",
	"tags": [],
	"description": "",
	"content": " Tuto 1 ASM Pour débuter l\u0026rsquo;apprentissage de l\u0026rsquo;assembleur.\n"
},
{
	"uri": "/tuto-asm-01/02/02structure/",
	"title": "02-Structure du MSX",
	"tags": [],
	"description": "",
	"content": " Je vais présenter uniquement ce qui est utile pour débuter le programme assembleur.\nLe MSX c\u0026rsquo;est un processeur Z80 (le coeur). Il discute avec 3 organes principaux :\n Le VDP : Un processeur qui gère l\u0026rsquo;affichage écran (16ko de mémoire).\n Le PSG : Un processeur qui gère le son.\n Le PPI : Un processeur qui gère le clavier notamment.  Revenons au Z80, il dispose de 3 sortes de mémoires :\n La ROM.\n La RAM.\n Les registres internes.  Les mémoires sont des cases. Pour pouvoir les différencier, on leur a donné des numéros que l\u0026rsquo;on appelle Adresse (comme les numéros des maisons dans une rue).\n Ces adresses vont de 0 à 65535.\n Chaque adresse peut contenir un nombre entre 0 et 255.  ROM Appelée mémoire morte. On peut simplement lire cette mémoire.\nOn ne peut pas la modifier (données constructeur).\nElle contient de petits programmes (routines) bien pratiques que l\u0026rsquo;on utilisera en assembleur pour lancer des actions ou faire des calculs.\nRAM Appelée mémoire vive. Elle est modifiable et c\u0026rsquo;est celle que nous utiliserons pour programmer. Par contre elle s\u0026rsquo;efface dès que l\u0026rsquo;on éteint le MSX. C\u0026rsquo;est pour cela que l\u0026rsquo;on sauvegarde nos programmes.\nRegistres internes Ce sont des sortes de mémoires. Ils n\u0026rsquo;ont pas d\u0026rsquo;adresse mais des lettres. En assembleur, c\u0026rsquo;est avec eux (une vingtaine environ) que l\u0026rsquo;on va jouer. On va rappeler des adresses, lire ou écrire dedans et faire des calculs. Et tout ça, c\u0026rsquo;est avec l\u0026rsquo;aide de ces registres que l\u0026rsquo;on va le faire.\nIl existe une page très simple et explicative du fonctionnement de ces registres du Z80 : Wiki Z80\nIl est important que l\u0026rsquo;on parle du VDP pour finir car c\u0026rsquo;est avec lui que l\u0026rsquo;on va discuter fréquemment pour afficher nos sprites et les faire bouger. Je passe volontairement sur les autres processeurs (PSG et PPI), on y reviendra au besoin.\nVDP Ce processeur permet d\u0026rsquo;afficher des images, des caractères ou des sprites à l\u0026rsquo;écran. Il contient 16ko de mémoire, appelée VRAM (dans laquelle on peut lire et écrire) et 9 registres internes (R0 à R7+ 1 registre d\u0026rsquo;état) qui ne sont pas les mêmes que ceux du Z80. La VRAM est divisée en 5 tables : 3 pour gérer l\u0026rsquo;affichage des caractères et 2 pour les sprites. Ces tables ne sont rien d\u0026rsquo;autre qu\u0026rsquo;un groupe d\u0026rsquo;adresses pouvant stocker des nombres. Les 3 tables des caractères:\n- TGP (Table Génératrice des Patrons): C\u0026rsquo;est là que l\u0026rsquo;on stocke les formes des caractères. Quand on tape la lettre A, le processeur Z80 demande au VDP de choisir la forme correspondant à la lettre A dans cette table.\n- TNP (Table des Noms des Patrons): C\u0026rsquo;est là que l\u0026rsquo;on va indiquer où afficher le caractère à l\u0026rsquo;écran.\n- TC (Table des Couleurs): C\u0026rsquo;est dans cette table que l\u0026rsquo;on va choisir la couleur du caractère et du fond de ce caractère.\n\rLe principe de fonctionnement de ces 3 tables est le suivant : on demande au processeur VDP d\u0026rsquo;afficher un (ou des) caractère(s) en définissant ce que l\u0026rsquo;on veut afficher, où on veut l\u0026rsquo;afficher et dans quelle couleur. Et comme on connait maintenant les tables de caractères, on pourra modifier la forme de ces derniers à volonté (par exemple pour dessiner un décor de jeu).\nLes 2 tables des sprites:\n-TGS (Table Génératrice des Sprites): Stocke les dessins des sprites que l\u0026rsquo;on va définir.\n-TAS (Table des Attributs des Sprites): stocke la position, le numéro et la couleur de chaque sprite.\n\rChacune de ces 5 tables débute par une adresse que l\u0026rsquo;on doit connaitre pour pouvoir y intégrer une liste d\u0026rsquo;informations, qui seront stockées à partir de là, vers les adresses suivantes en fonction du nombre d\u0026rsquo;informations (données) à stocker.\nPour définir automatiquement ces adresses de début en suivant les données constructeur, le VDP utilise 4 modes de fonctionnement :\n SCREEN 0 : Le mode texte\n SCREEN 1 : Le mode graphique 1\n SCREEN 2 : Le mode graphique 2\n SCREEN 3 : Le mode multicolore  Le programme assembleur que je veux expliquer utilise le SCREEN 1 donc je ne parlerai que de celui-là pour l\u0026rsquo;instant.\nLe SCREEN 1 sur MSX1 c\u0026rsquo;est 32 colonnes sur 24 lignes de texte et la possibilité d\u0026rsquo;utiliser les sprites.\n"
},
{
	"uri": "/traductions/",
	"title": "Traductions",
	"tags": [],
	"description": "",
	"content": " Traductions MSX Traductions de documents relatifs au MSX.\n"
},
{
	"uri": "/traductions/musique/",
	"title": "Traductions Musique",
	"tags": [],
	"description": "",
	"content": " PSG (MUSIQUE) Manuel du VORTEX TRACKER II :\n VORTEX TRACKER II.pdf  Manuel du WYZ TRACKER :\n Manuel WYZ Tracker.pdf  \r\rFichiers associés\r\r\rManuel WYZ Tracker.pdf\r\r(751 ko)\r\r\rVORTEX TRACKER II.pdf\r\r(324 ko)\r\r\r\r"
},
{
	"uri": "/tuto-asm-01/03/03affchr/",
	"title": "03-Afficher un caractère",
	"tags": [],
	"description": "",
	"content": " (La théorie) Un caractère affiché par le VDP c\u0026rsquo;est 3 tables auxquelles on devra donner des instructions:\n TNP (position à l\u0026rsquo;écran)\n TGP (la forme du caractère)\n TC (la couleur du caractère et du fond de celui-ci)\n  TNP  En mode SCREEN 1, on a vu que la TNP débute à l\u0026rsquo;adresse 6144.\n On sait aussi qu\u0026rsquo;en SCREEN 1 on a 32 colonnes pour 24 lignes (pour le texte). Cela donne 768 positions possibles à l\u0026rsquo;écran (32 x 24 = 768).\nCes positions vont de gauche à droite (comme le fonctionnement d\u0026rsquo;une machine à écrire), de la position 0 à 31 pour la première ligne, puis passe à la ligne 2 et poursuit la numérotation jusqu\u0026rsquo;à la dernière position N° 768 en bas à droite.\nVoici l\u0026rsquo;écran telle qu\u0026rsquo;il est en SCREEN 1 :  TNP Screen 1 \nToutes les positions sont des adresses mémoires qui se suivent. Sachant que la TNP débute à l\u0026rsquo;adresse 6144, on sait maintenant que cette adresse correspond à la position 0. Si on veut afficher le caractère à la position 5, on va simplement faire 6144+5 et on aura l\u0026rsquo;adresse où afficher le caractère: 6149\nTGP On a vu que c\u0026rsquo;était la table qui abrite les formes des caractères. Cette table contient 256 caractères numérotés sous la norme standard internationale ASCII.\n Table des caractères \nUn exemple avec le tableau ci-dessus :\nVous voulez le code ASCII de la lettre \u0026lsquo;A\u0026rsquo;, vous prenez le N° de ligne et de colonne (respectivement), ici 4 et 1, vous l\u0026rsquo;assemblez et cela donne du hexadécimal : 41\nEn assemblage on utilise beaucoup l\u0026rsquo;hexadécimal pour des raisons que je n\u0026rsquo;expliquerai pas ici.\nMais il est facile de traduire de l\u0026rsquo;hexadécimal vers le décimal (et inversement), avec une calculatrice.\nCelle de Windows le fait très bien, il suffit de choisir dans le menu : Affichage/Programmeur.\nVous cochez : Vous rentrez le nombre 41, il ne vous reste plus qu\u0026rsquo;à cocher\nDéc  et vous obtenez du décimal, dans notre cas 65, qui est le n° ASCII de la lettre \u0026lsquo;A\u0026rsquo; que reconnait la TGP, ouf !!!\nJuste pour information, l\u0026rsquo;adresse de la lettre \u0026lsquo;A\u0026rsquo; dans la TGP n\u0026rsquo;est pas 65. Chaque caractère est défini dans une grille de 8 x 8 (comme un sprite simple).\nDonc chaque caractère prend 8 adresses mémoires successives dans la TGP.\nLa TGP débute en 0 (SCREEN 1), notre \u0026lsquo;A\u0026rsquo; est le 65ème, donc son adresse de début de forme est : Adresse de début de la TGP + 65*8 = 0 + 520 = 520\nSi on voulait modifier la forme du \u0026lsquo;A\u0026rsquo; il faudrait que l\u0026rsquo;on modifie les valeurs des adresses 520 à 527 (8 octets), mais on va pas le faire dans notre exemple.\nAvec l\u0026rsquo;adresse et le code du caractère, on est déjà capable de l\u0026rsquo;afficher, la couleur est optionnelle. On va quand même voir comment la TC fonctionne.\nTC Pour modifier cette table, il nous faut 2 informations :\nL\u0026rsquo;adresse du caractère dans cette table. Le calcul de sa couleur.  Dans notre exemple, le \u0026lsquo;A\u0026rsquo; c\u0026rsquo;est le numéro 65, on le divise par 8 et on ajoute ce résultat au début de l\u0026rsquo;adresse de la table (8192 en SCREEN1). (65:8) + 8192 = 8200 (on ne retient que la part entière).\n 8200 c\u0026rsquo;est l\u0026rsquo;adresse du \u0026lsquo;A\u0026rsquo; dans la TC.\n Pour la couleur (16 couleurs disponibles en SCREEN 1), le calcul est :\nCouleur du caractère x 16 + couleur de fond du caractère. Pour un caractère Magenta (couleur 13) et Fond Blanc (couleur 15) cela donne:\n13 x 16 + 15 = 223\nDonc si on veut modifier une couleur, on passe par cette table et on modifie la valeur de l\u0026rsquo;adresse 8200 en lui mettant 223. Affiche le caractère \u0026lsquo;A\u0026rsquo; à l\u0026rsquo;écran\nVoilà, on va mettre tout cela en application en utilisant enfin un assembleur pour MSX.\nL\u0026rsquo;article suivant va uniquement parler de la mise en place des outils pour programmer en assembleur.\nC\u0026rsquo;est le préalable à la mise en pratique de ce que nous avons vu jusqu\u0026rsquo;ici.\n"
},
{
	"uri": "/dynamicpub/",
	"title": "Dynamic Publisher",
	"tags": [],
	"description": "",
	"content": " Découverte de Dynamic Publisher sur MSX. C\u0026rsquo;est un des premier éditeur / PAO sur ordinateur.\nLes articles sont réalisés sur le MSX.\n"
},
{
	"uri": "/traductions/zemmixneo/",
	"title": "Traduction Zemmix Neo",
	"tags": [],
	"description": "",
	"content": " CONSOLE ZEMMIX NEO Manuel Zemmix Neo en français :\n Manuel Zemmix Neo.pdf  \r\rFichiers associés\r\r\rZemmix-Neo-Lite_Manuel-utilisateur.pdf\r\r(1392 ko)\r\r\r\r"
},
{
	"uri": "/tuto-asm-01/04/04-mise-en-place/",
	"title": "04-Mise en place",
	"tags": [],
	"description": "",
	"content": " des outils de développement On va avoir besoin d\u0026rsquo;installer 3 programmes :\n Un émulateur (simule un MSX)\n Un éditeur de texte (pour taper du code texte assembleur)\n un assembleur (compile le code texte en code machine utilisable par un MSX)  Pour cela j\u0026rsquo;ai suivi les explications du site d\u0026rsquo;un développeur anglais dont je vous donne l\u0026rsquo;adresse de sa chaine Youtube :\nLets Make a Retro Game\nEMULATEUR L\u0026rsquo;émulateur MSX s\u0026rsquo;appelle blueMSX, je vous invite à le télécharger à l\u0026rsquo;adresse suivante dans la section téléchargement : http://www.bluemsx.com\nVous l\u0026rsquo;installez où vous voulez, il n\u0026rsquo;y a rien de particulier.\nQuand vous le lancez pour la première fois, je vous invite à aller dans le le menu, choisir Outils, ensuite Editeur de machine et dans le champ Configuration vous sélectionnez MSX-French et vous cliquez sur le bouton [Lancer].\nVous avez un MSX francais qui démarre,vous validez par [Entrée] quand il vous demande la date.\nEDITEUR DE TEXTE On va installer un éditeur de texte qui s\u0026rsquo;appelle CONTEXT Editor, il est simple d\u0026rsquo;utilisation et permettra de lancer la compilation avec des touches de raccourci.\nLe liens de téléchargement est le suivant :\nCONTEXT Editor\nInstallez en suivant la procédure proposée par défaut.\nLe développeur du site que j\u0026rsquo;ai indiqué nous met à disposition un petit plugin qui permet de mettre en couleur le texte assembleur, il se trouve ici : coloration de syntaxe\nPour ajouter le colorateur syntaxique à CONTEXT il faut coller le fichier WLA DX Z80 Assembler.chl dans le dossier suivant :\nC:\\Program Files (x86)\\ConTEXT\\Highlighters Le dossier sera le suivant si vous êtes en mode Windows 32-bit :\nC:\\Program Files\\ConTEXT\\Highlighters\nASSEMBLEUR Pour l\u0026rsquo;assembleur, c\u0026rsquo;est tniASM (v0.45).\nIl est simple et pratique lui aussi.\nVoici l\u0026rsquo;adresse : tniasm 0.45\nVous téléchargez la version gratuite et vous la dézippez dans le répertoire suivant sur votre PC :\nC:\\tniasm045\nVous devez ainsi avoir les 2 fichiers suivant dans le dossier \u0026lsquo;tniasm045\u0026rsquo; :\n tniasm.exe\n tniasm.txt  Le fichier tniasm.txt est la documentation de l\u0026rsquo;outil, mais en anglais. Vu que je me suis \u0026lsquo;cogné\u0026rsquo; la traduction en français, autant qu\u0026rsquo;elle serve : doc française de tniasm à télécharger en bas de cette page.\nCONTEXT-TOUCHE RACCOURCI Afin de rendre CONTEXT plus facile d\u0026rsquo;utilisation, on peut paramétrer des touches de raccourci pour compiler le code automatiquement, et faire apparaître les lignes d\u0026rsquo;erreur.\nDans le menu de CONTEXT choisissez \u0026lsquo;Options / Environment Options / Execute Keys vous devez avoir cet écran :\nCliquez sur le bouton [Add] et remplissez avec asm,z80 Ainsi, on va définir une action pour tous les fichiers qui ont une extension de type .asm ou .z80.\nCliquez sur [OK]. Vous devriez obtenir cela dans la petite fenêtre de gauche :\nCliquez sur la touche de fonction F9 dans cette petite fenêtre et ensuite remplissez les champs à droite comme suit :\n   champs Valeur à taper     Execute c:\\tniasm045\\tniasm.exe   Start in %p   Parameters %n   Window Normal   Hint Compile   Save Current file before execution   Use short Dos names Not ticked   Capture console output Ticked   Compiler output parser rule *line%l(%n)*   Scroll console to the last line Ticked    Vous obtenez ceci :\nQuand on voudra compiler du code assembleur, on aura plus qu\u0026rsquo;à appuyer sur F9 et cela se fera automatiquement, ou s\u0026rsquo;il y a une erreur de compilation on le verra dans la fenêtre basse de CONTEXT.\nPour tester cet environnement on utilisera des fichiers source, c\u0026rsquo;est l\u0026rsquo;objet du prochain article.\nJe tiens à remercier celui qui a fait cette procédure d\u0026rsquo;installation, que je n\u0026rsquo;ai fait que traduire et adapter à notre exemple, visitez son site : http://www.electricadventures.net/\n\r\r\rFichiers associés\r\r\rtniasm_fr.txt\r\r(29 ko)\r\r\r\r"
},
{
	"uri": "/traductions/megaflasrom/",
	"title": "Traductions MegaFlashROM",
	"tags": [],
	"description": "",
	"content": " MegaflashROM SCC+SD Traduction du manuel et d\u0026rsquo;une procédure d\u0026rsquo;utilisation.\n\r\rFichiers associés\r\r\rMegaFlashROM SCC\u0026#43; SD Manuel Utilisateur.pdf\r\r(543 ko)\r\r\rMegaFlashROM.pdf\r\r(255 ko)\r\r\r\r"
},
{
	"uri": "/tuto-asm-01/05/05-decouverte/",
	"title": "05-Découverte du code",
	"tags": [],
	"description": "",
	"content": " Fichiers sources et découverte du code assembleur MSX Pour faire fonctionner l\u0026rsquo;environnement que l\u0026rsquo;on a mis en place, on a besoin d\u0026rsquo;un document où taper notre code.\nIl se présente sous la forme d\u0026rsquo;un petit fichier texte comme on peu en utiliser avec le blocnote de Windows. Sauf que le notre aura une extension de fichier qui se termine par .asm au lieu du traditionnel .txt\nC\u0026rsquo;est lui que l\u0026rsquo;on va ouvrir avec l\u0026rsquo;éditeur de texte CONTEXT, c\u0026rsquo;est lui qui va recevoir le code que l\u0026rsquo;on va taper et c\u0026rsquo;est encore lui que l\u0026rsquo;on va compiler via la touche de fonction F9. Cette compilation nous donnera un fichier exploitable par l\u0026rsquo;émulateur MSX.\nCe fichier ne peut pas être compilé tout seul, il a besoin de se trouver dans le même dossier ou vont figurer 2 fichiers sources (appelées librairies) et qui aideront à la compilation.\nEn effet notre fichier principal comporte un entête et un pied de page que l\u0026rsquo;on ne touchera pas mais qui à l\u0026rsquo;aide des librairies feront qu\u0026rsquo;à la compilation on se retrouvera avec un fichier de sortie qui aura l\u0026rsquo;extension .ROM.\nEt miracle, cela simulera les fameuses cartouches ROM de notre enfance qui démarraient automatiquement quand on allumait notre bon vieux MSX.\nCe fichier ne peut pas être compilé tout seul, il a besoin de se trouver dans le même dossier ou vont figurer 2 fichiers sources (appelées librairies) et qui aideront à la compilation. En effet notre fichier principal comporte un entête et un pied de page que l\u0026rsquo;on ne touchera pas mais qui à l\u0026rsquo;aide des librairies feront qu\u0026rsquo;à la compilation on se retrouvera avec un fichier de sortie qui aura l\u0026rsquo;extension.ROM. Et miracle, cela simulera les fameuses cartouches ROM de notre enfance qui démarraient automatiquement quand on allumait notre bon vieux MSX.\nBon on résume avec un schéma :\nBon, j\u0026rsquo;espère que c\u0026rsquo;est plus clair maintenant.\nAvant que je ne vous donne le liens de téléchargement des fichiers sources, je vais vous les présenter:\nLe fichier principal, celui où on tapera notre code (pour l\u0026rsquo;instant, il n\u0026rsquo;y a que l\u0026rsquo;entête et le pied de page à l\u0026rsquo;intérieur) :\nexample.asm  Les 2 librairies, qui doivent se trouver toujours dans le même dossier que le fichier principal sinon l\u0026rsquo;assembleur ne saura pas où les trouver :\nMSXRom-Include.asm MSXRom-Lib.asm  Pour le lien du dossier : fichiers source à télécharger en bas de cette page. Je me dois encore remercier celui qui a fourni ces sources, c\u0026rsquo;est son travail : http://www.electricadventures.net/\n\rVous ouvrez exemple.asm avec CONTEXT et on va en profiter pour utiliser le colorateur syntaxique qui reconnait le langage assembleur et que l\u0026rsquo;on a téléchargé précédemment.\nDonc, dans le menu de CONTEXT, choisissez Tools / Set Highlighter et dansla liste des codes connus, vous devez trouver WLA-Z80 Assembler, sélectionnez-le.\nSi vous voulez faire apparaître les numéros de ligne sous CONTEXT (utile pour le debuggage), dans le menu de CONTEXT, choisissez Options / Environment Options / onglet Editor et vous cochez Line numbers.\nVous devez en être là :\n2 fenêtres:\n La partie haute : zone où on tape le code. La partie basse : zone de suivi de la compilation quand on fait F9.  Regardons ce code depuis le début :\n; **************************************************************** ; MSX ROM Cartridge Header and Function library ; **************************************************************** FNAME \"exemple.ROM\" cpu z80 ORG 4000h INCLUDE \"MSXRom-Include.asm\" db \"AB\" DW INIT ; la ROM lance le sous-programme INIT au démarrage DW 0 DW 0 DW 0 DS 6  C\u0026rsquo;est ce que j\u0026rsquo;appelle l\u0026rsquo;entête.\nFNAME: c\u0026rsquo;est le nom du fichier qui sortira à la compilation, vous pouvez donc mettre le nom que vous voulez entre les \u0026ldquo; \u0026rdquo; du moment que vous conservez l\u0026rsquo;extension.ROM.\ncpu Z80: La compilation utilisera la librairie Z80 (tniASM en gère plusieurs).\nORG 4000h: Notre programme s\u0026rsquo;implantera à cette adresse au démarrage de la ROM dans l\u0026rsquo;émulateur. Pour info, quand un nombre est suivi de \u0026lsquo;h\u0026rsquo; c\u0026rsquo;est que l\u0026rsquo;on indique que c\u0026rsquo;est un Hexadécimal sinon, c\u0026rsquo;est un décimal.\nINCLUDE: C\u0026rsquo;est pour cela que je vous disais que les librairies doivent être dans le même dossier, car à la compilation, tniASM va chercher tous les fichiers cité par in INCLUDE et qui va lui permettre d\u0026rsquo;interpréter le code spécifique à l\u0026rsquo;assembleur MSX.\nDW INIT: Cette suite de DW permet de créer une structure de ROM à la compilation d\u0026rsquo;après ce que j\u0026rsquo;en ai compris. Ce qui est important, c\u0026rsquo;est le mot INIT, cela aurait pu être n\u0026rsquo;importe quoi FRAISE, MARTEAU,etc\u0026hellip;\nCela intime l\u0026rsquo;ordre au démarrage de la ROM d\u0026rsquo;aller déclencher le code qui commence par ce \u0026lsquo;label\u0026rsquo;. Ces \u0026lsquo;labels\u0026rsquo; sont des bout de programmes appelés routines qui que l\u0026rsquo;on pourra appeler au besoin. En effet, en assembleur, on ne dispose pas des lignes comme en BASIC alors on appelle des \u0026lsquo;labels\u0026rsquo; pour sauter à une partie du programme.\nLe pied de page est présenté ici mais je n\u0026rsquo;en parlerai pas, il ne vous apprendra rien de plus : En fait, je ne le maîtrise pas, alors je le laisse ;-)\nPour info, lorsque on tape un point virgule ; ce qui suis sur la ligne est du commentaire et ne sera pas interprété comme du code par l\u0026rsquo;assembleur.\n;************************************************************************************************** ; Standard Libraries ;************************************************************************************************** INCLUDE \"MSXRom-Lib.asm\" ; intègre la librairie MSX END: EQU $ ;************************************************************************************************** ; RAM Definitions ;************************************************************************************************** ;------------------- ; Définit que le programme démarrera au début de la RAM disponible ;------------------- ORG RAMSTART  Ce qui nous intéresse se trouve entre ces 2 parties :\n;------------------------------------------------------------------------------ ; Démarrage du programme à INIT ;------------------------------------------------------------------------------ INIT: ; Tapez votre code à partir d'ici  C\u0026rsquo;est ici que nous allons taper notre 1er code\u0026hellip;.dans le prochain article.\n\r\rFichiers associés\r\r\rsources.zip\r\r(5 ko)\r\r\r\r"
},
{
	"uri": "/tuto-asm-01/06/06-afficher_chr/",
	"title": "06-La pratique",
	"tags": [],
	"description": "",
	"content": " La pratique : Afficher un caractère On va maintenant taper notre 1er code qui permettra :\n  Activer le mode SCREEN 1. Afficher le caractère A à la position 5 de l\u0026rsquo;écran. Changer la couleur du caractère et du fond du caractère. Faire une boucle infinie pour que le résultat de cet affichage reste à l\u0026rsquo;écran.   Voici ce que cela donne pour l\u0026rsquo;ensemble du code, mais on va le reprendre bout par bout :\n;------------------------------------------------------------------------------ ; Démarrage du programme à INIT ;------------------------------------------------------------------------------ INIT: Ld a,1 ; 1 pour 'SCREEN 1' ld [64687],a ; routine BIOS [SCRMOD] : mode courant de l'écran call 95 ; routine BIOS [CHMOD] : change le mode l'écran ld a,65 ; on charge l'accumulateur avec 65 (ASCII de 'A') ld hl,6144+5 ; on charge en HL l'adresse de la TNP + 5 (position 5) call 77 ; routine BIOS [WRTVRM] : écrit dans la VRAM (write to VRAM) ld a,223 ; on charge le code couleur (magenta sur blanc=223) ld hl,8200 ; on charge l'adresse de la TC pour le caractère 'A' call 77 ; routine BIOS [WRTVRM] : écrit dans la VRAM (write to VRAM) BOUCLE: ; A la fin d'INIT, le programme n'est pas stoppé alors il continue JP BOUCLE ; dans le prochain label, ici BOUCLE (comparable à 100 GOTO 100)  C\u0026rsquo;est parti :\nEn mode assembleur, en général, on charge un accumulateur A avec une valeur entre 0 et 255, et une adresse en HL (ce sont les registres internes avec lesquels la RAM fait les calculs) puis on lance l\u0026rsquo;odre d\u0026rsquo;exécution par un CALL.\nSCREEN 1 C\u0026rsquo;est l\u0026rsquo;exemple type, l\u0026rsquo;adresse 64687 est une routine BIOS qui abrite le mode courant de l\u0026rsquo;écran (SCREEN 1, 2 ou 3).\n Donc la 1ere ligne charge (c\u0026rsquo;est l\u0026rsquo;instruction \u0026lsquo;LD\u0026rsquo;) A avec 1 donc A=1. On assigne cette valeur à l\u0026rsquo;adresse 64687 (2eme ligne). Et enfin on donne l\u0026rsquo;ordre via une routine spécifique du BIOS en ROM d\u0026rsquo;exécuter cela. Après le CALL le SCREEN 1 est effectif.  ;------------------------------------------------------------------------------ ; Démarrage du programme à INIT ;------------------------------------------------------------------------------ INIT: Ld a,1 ; 1 pour 'SCREEN 1' ld [64687],a ; routine BIOS [SCRMOD] : mode courant de l'écran call 95 ; routine BIOS [CHMOD] : change le mode l'écran  Au départ ces adresses et routines appelées semblent obscures mais celles que l\u0026rsquo;on utilise régulièrement sont en nombre réduit et deviendront familières rapidement. J\u0026rsquo;utilise souvent le décimal, mais CALL 95 peut s\u0026rsquo;écrire aussi CALL $5F en hexadécimal, tniasm reconnait la plupart des expressions pour l\u0026rsquo;hexadécimal (voir sa doc).\nUn site pour voir la liste des routines BIOS : http://map.grauw.nl/resources/msxbios.php\n CHGMOD\nAddress : #005F\nFunction : Switches to given screenmode\nInput : A - screen mode\nRegisters: All\n AFFICHAGE DU \u0026lsquo;A\u0026rsquo; Là, ça doit vous parler, on connait la valeur du caractère \u0026lsquo;A\u0026rsquo; en ASCII = 65.\nOn a vu dans la théorie que le début de la table TNP (qui gère les positions d\u0026rsquo;affichage) est à l\u0026rsquo;adresse 6144 en SCREEN 1. On a choisit arbitrairement la position 5 (vous pouvez vous amuser avec une autre valeur).\nPetite nouveauté, le CALL 77 (CALL $4D) qui exécute l\u0026rsquo;ordre du calcul que l\u0026rsquo;on vient de faire attend A et HL chargés en entrants :\n WRTVRM\nAddress : #004D\nFunction : Writes data in VRAM\nInput : HL - address write\nA - value write\n Voici le bout de code correspondant :\nld a,65 ; on charge l\u0026rsquo;accumulateur avec 65 (ASCII de \u0026lsquo;A\u0026rsquo;) ld hl,6144+5 ; on charge en HL l\u0026rsquo;adresse de la TNP + 5 (position 5) call 77 ; routine BIOS [WRTVRM] : écrit dans la VRAM (write to VRAM) \nCHANGER LA COULEUR DU CARACTERE Même punition. Tout est dans le commentaire du code : ld a,223 ; on charge le code couleur (magenta sur blanc=223) ld hl,8200 ; on charge l\u0026rsquo;adresse de la TC pour le caractère \u0026lsquo;A\u0026rsquo; call 77 ; routine BIOS [WRTVRM] : écrit dans la VRAM (write to VRAM) \nBOUCLE INFINIE On se rajoute cette boucle pour ne pas revenir au BASIC et perdre l\u0026rsquo;affichage.\nBOUCLE: ; A la fin d\u0026rsquo;INIT, le programme n\u0026rsquo;est pas stoppé alors il continue JP BOUCLE ; dans le prochain label, ici BOUCLE (comparable à 100 GOTO 100) \nIl n\u0026rsquo;y a plus qu\u0026rsquo;a compiler et demander à l\u0026rsquo;émulateur d\u0026rsquo;utiliser le fichier généré qui doit être \u0026ldquo;testA.ROM\u0026rdquo;\u0026hellip;.vous vous souvenez, le FNAME dans l\u0026rsquo;entête, au début du code, ben je l\u0026rsquo;ai modifié ainsi pour changer le nom de fichier généré.\nCOMPILATION On clique sur la touche de fonction [F9], cela sauvegarde notre fichier texte et lance la compilation.\nVous pouvez aussi procéder autrement: Sauvegardez votre fichier et dans l\u0026rsquo;explorateur Windows, faites glissez votre \u0026ldquo;testA.asm\u0026rdquo; sur \u0026ldquo;tniasm.exe\u0026rdquo; avec la souris et cela va déclencher la compilation et créer le fichier en sortie dans le même dossier. Cela sous-entend que tniasm est dans le même dossier que votre code et ses librairies. L\u0026rsquo;inconvénient c\u0026rsquo;est que vous ne savez pas s\u0026rsquo;il y a des erreurs de compilation.\nOn voit que la fenêtre basse de CONTEXT a changée : On voit les 2 passes pour générer le fichier .ROM et pas d\u0026rsquo;erreur.\nSi vous avez une erreur, elle se présentera de cette manière :\nCONTEXT indique la ligne d\u0026rsquo;erreur, ici pour l\u0026rsquo;exemple c\u0026rsquo;est la ligne 22.\nQuand on regarde notre code, on voit que l\u0026rsquo;on a ajouté un t par erreur\u0026hellip;.c\u0026rsquo;est pas toujours aussi évident, je vous l\u0026rsquo;accorde.\nFICHIER .ROM GENERE Si tout c\u0026rsquo;est bien passé, notre répertoire où se trouve notre code doit ressembler à ceci :  Les 2 librairies\n Notre code principal : \u0026ldquo;testA.asm\u0026rdquo; Le fichier \u0026ldquo;testA.ROM\u0026rdquo; généré, c\u0026rsquo;est celui-ci qui nous intéresse.\n 3 fichiers de compilations (en surligné dans l\u0026rsquo;image ci-dessus) que l\u0026rsquo;on n\u0026rsquo;utilisera pas.\n  On va prendre le \u0026ldquo;testA.rom\u0026rdquo; et le faire glisser avec la souris dans l\u0026rsquo;émulateur blueMSX que vous aurez ouvert au préalable.\nBlueMSX va rebooter le MSX et au bout de quelques secondes on doit admirer\u0026hellip;..un caractère\u0026hellip;..mais en couleur s\u0026rsquo;il vous plait !!!\nOn voit dans le bandeau en bas que dans le champs \u0026lsquo;SCREEN\u0026rsquo; nous sommes bien passé en \u0026lsquo;SCR 1\u0026rsquo;\nEJECTER LA ROM ET QUITTER Vous vous rappelez que nous avons mis une boucle infinie à la fin de notre code, de ce fait nous ne pouvons avoir d\u0026rsquo;action sur l\u0026rsquo;émulateur et si vous le rebootez en appuyant sur le gros bouton rond en haut à gauche (à côté du point rouge), blueMSX va relancer la machine mais aussi notre fichier .ROM.\nEn effet, nous venons de créer une cartouche 16ko et elles sont faites pour démarrer automatiquement.\nDonc si vous voulez éjecter la cartouche, vous appuyez sur le bouton rond à côté de slot et choisissez Ejecter: testA.ROM :\nblueMSX va rebooter la machine automatiquement mais sans la cartouche et rendre la main à l\u0026rsquo;invite de commande du BASIC.\nLe prochain article on apprendra à afficher les sprites, pour cela on partira directement sur l\u0026rsquo;élaboration du shoot-em-up.\n"
},
{
	"uri": "/tuto-asm-01/07/07-shoot/",
	"title": "07-un shoot-em-up",
	"tags": [],
	"description": "",
	"content": " Organigramme Maintenant que l\u0026rsquo;on a vu comment utiliser les tables relatives aux caractères, on va mettre en pratique la 2eme partie des tables du VDP : L\u0026rsquo;affichage des sprites.\nAvant de commencer, je vais vous parler du programme de shoot-em-up basique qui fait l\u0026rsquo;objet de ce blog.\nCar on va commencer à écrire ce programme. En effet, il a l\u0026rsquo;avantage d\u0026rsquo;être très simple et d\u0026rsquo;aborder les grands principes d\u0026rsquo;un jeu, c\u0026rsquo;est avec lui que l\u0026rsquo;on abordera la mise en pratique de l\u0026rsquo;affichage des sprites dans un premier temps.\nMais ce programme nous permettra d\u0026rsquo;aller plus loin et d\u0026rsquo;aborder des sujets complémentaires comme :\n le déplacement du sprite-joueur,\n le déplacement du sprite-ennemi,\n la gestion du tir pour le joueur, la gestion de la collision,\n la gestion d\u0026rsquo;un temporisation basique,\n la construction d\u0026rsquo;une boucle principale qui gère tous cela.  Avant de rentrer dans le code, vous devez avoir une vue d\u0026rsquo;ensemble (organigramme) du projet et comment il est organisé, sinon vous ne comprendrez pas le découpage du programme.\nUn programme en assembleur est la plupart du temps décomposé en une succession de petits programmes que l\u0026rsquo;on peut appeler blocs, routines, etc\u0026hellip; Ils exécutent un calcul ou une action (voire les deux) d\u0026rsquo;un domaine bien précis. Par exemple, on peut faire un bloc qui s\u0026rsquo;occupe de la mise en place des sprites, un autre pour la gestion des touches directionnelles du clavier, un autre pour la gestion de la collision des sprites, etc\u0026hellip;\nL\u0026rsquo;avantage, c\u0026rsquo;est que l\u0026rsquo;on visualise mieux des blocs qui gèrent un seul sujet, on y comprend mieux le code, on saura mieux repérer les éventuelles erreurs, on pourra améliorer le programme en modifiant bloc par bloc sans tout casser.\nAinsi, on peut tout découper et faire en sorte que notre programme principal ne soit qu\u0026rsquo;une succession d\u0026rsquo;appel de ces blocs dans un ordre qui nous convienne. Ce programme principal sera une boucle assez simple et lisible mais qui pourra faire beaucoup de chose par de simples appels à ces sous-programmes.\nVoici un découpage possible par blocs :\nOn va faire démarrer la cartouche .ROM pour qu\u0026rsquo;elle appelle le programme principal, qui se comporte comme la boucle infinie que nous avons codé pour l\u0026rsquo;affichage d\u0026rsquo;un caractère\u0026hellip;..bon, je vous le remontre :\nBOUCLE: JP BOUCLE \nOn voit d\u0026rsquo;ailleurs qu\u0026rsquo;un bloc (ou sous-programme) débute par un nom suivit de 2 points :\nCa s\u0026rsquo;appelle un label, je vous ai déjà dit qu\u0026rsquo;en assembleur on n\u0026rsquo;a pas les numéros de ligne pour appeler un code, on utilise des déclarations de labels que l\u0026rsquo;on pourra appeler via un *CALL sans les 2 points \u0026lsquo;:\u0026rsquo; Dans notre exemple ci-dessus, si je voulais appeler mon programme principal, je taperai CALL BOUCLE.\nJP veut dire Jump (saute), donc le bloc se comporte de cette façon:\n BOUCLE: Je m\u0026rsquo;appelle BOUCLE\n JP BOUCLE Saute au label BOUCLE  Si on ne faisait pas cette boucle infinie, tous le jeux serait installé puis il s\u0026rsquo;arrêterait, nous ce que l\u0026rsquo;on veut c\u0026rsquo;est que le jeux déplace constamment l\u0026rsquo;ennemi, le joueur, surveille le clavier directionnel en permanence.\nPar contre, la plupart des autres sous-programmes ne vont pas se finir par un JP de son propre label.\nIls sont appelés par le programme principal pour réaliser un calcul ou une action bien précise et rendent la main.\nPar exemple, si le programme principal surveille le clavier directionnel et qu\u0026rsquo;en fonction de la flèche pressée, il fait appel à un sous-programme qui déplace le joueur d\u0026rsquo;un petit espace et rend la main au programme principal, car ce dernier à besoin de controler si une autre touche est pressée.\nDonc ce sous-programme se terminera par un RET pour return (retour) et non pas par un JP.\nVous allez mieux comprendre maintenant l\u0026rsquo;organigramme de ces blocs que j\u0026rsquo;ai volontairement vulgarisé (on verra dans la pratique qu\u0026rsquo;il est plus subtil) et comment ils peuvent intéragir :\nJe vous promets, dès le prochain article on attaque le code directement ;-)\n"
},
{
	"uri": "/tuto-asm-01/08/08-sprite/",
	"title": "08-Afficher un sprite",
	"tags": [],
	"description": "",
	"content": " La pratique On va maintenant taper notre 1er code du shoot-em-up.\nOn va enlever la partie du code correspondant à l\u0026rsquo;affichage du caractère (qui était notre exemple précédent), et donc repartir du fichier sources vierge exemple.asm.\n Quelques informations sur le début du code :\n  Le programme est en SCREEN 1 3 SPRITES vont être créés (la fusée du joueur, l\u0026rsquo;ennemi/envahisseur, le tir)\n On charge les formes des SPRITES dans la table TGS\n On charge les attributs des SPRITES dans la table TAS\n On va positionner 3 indicateurs qui nous serviront à déplacer les SPRITES plus tard.\n On spécifie la taille des SPRITES  Voici l\u0026rsquo;entête, j\u0026rsquo;ai juste modifié le nom du fichier qui sera généré via FNAME : ; **************************************************************** ; MSX ROM Cartridge Header and Function library ; **************************************************************** FNAME \u0026ldquo;test1.ROM\u0026rdquo; cpu z80\nORG 4000h\nINCLUDE \u0026ldquo;MSXRom-Include.asm\u0026rdquo;\ndb \u0026ldquo;AB\u0026rdquo; DW INIT ; Fait démarrer la ROM au label INIT DW 0 DW 0 DW 0 DS 6 \nSCREEN 1 Passons au début du code proprement dit et par le label (appelé aussi \u0026ldquo;Etiquette\u0026rdquo;) \u0026lsquo;INIT:\u0026rsquo; (c\u0026rsquo;est par lui que la .ROM démarrera) :\n;------------------------------------------------------------------------------ ; Démarrage du programme à INIT ;------------------------------------------------------------------------------ INIT: LD A,1 ; 1 pour screen 1 ld [64687],A ; (bios)SCRMOD adresse $FCAF :mode courant de l'ecran call 95 ; (bios) CHGMOD : change le mode l'écran  Pas de modification par rapport aux précédent exemple, on se place en SCREEN 1.\nCHARGEMENT DE LA TGS ;------------------------------------------------------------------------------ ; Charge la TGS avec la forme des 3 sprites ;------------------------------------------------------------------------------ ld hl,donnee ; va chercher les données TGS au label: donnee ld de,14336 ; adresse du début de la TGS ld bc,24 ; longueur du bloc = 3 sprites de 8 octets = 24 call 92 ; LIDRVM transfert de bloc de la RAM vers la VRAM  Je commence par la fin, on va donner un ordre de transfert de données (les formes des SPRITES) qui seront écrites dans notre code (donc dans la RAM) vers la table TGS (donc la VRAM), on ne va pas pouvoir utiliser un ordre du style \u0026ldquo;écrire dans la VRAM\u0026rdquo; car cela est limité à une adresse mémoire et une donnée.\nPour de gros blocs de données entre RAM et VRAM, il existe une routine BIOS qui fait le boulôt : LIDRVM ou en langage assembleur CALL 92 (en décimal) ou CALL $5C (en hexadécimal). Cette routine, pour être déclenchée, a besoin de 3 paramètres en entrée :\n HL, pour les données des formes de sprites\n DE, l\u0026rsquo;adresse de la TGS à partir de laquelle on veut écrire (une donnée = une case mémoire)\n BC, la longueurde bloc total à transférer (en octets)  Voici d\u0026rsquo;ailleurs une définition de cette routine :\n LDIRVM\nAddress : #005C\nFunction : Block transfer to VRAM from memory\nInput : BC - blocklength\nDE - Start address of VRAM\nHL - Start address of memory\nRegisters: All\n Vu que l\u0026rsquo;on a 3 SPRITES à charger (8 pixels sur 8 pixels donc 8 octets) on a 3 x 8 = 24 données à envoyer en VRAM. On ne va pas les taper juste après la virgule du HL il ne saurait pas le traiter. On va plutôt lui dire où il peut les trouver et les \u0026ldquo;digérer à son rythme\u0026rdquo;, pour cela on va créer un nouveau label donnee qui abritera ces 24 données.\nLes données en général sont stockées plutôt à la fin du programme codé et chaque ligne doit commencer par un DB.\nCe label donnee je l\u0026rsquo;ai placé juste avant le pied de page, voici comment il se présente : ;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; ; Les données ;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; donnee: db 24,24,126,126 ; sprite 0 pour la TGS db 255,255,255,0 ; sprite 0 db 60,126,153,255 ; sprite 1 db 102,60,66,36 ; sprite 1 db 24,24,24,24 ; sprite 2 db 24,24,24,24 ; sprite 2 \nPour le SPRITE 0, les 2 premières lignes donnent 8 données qui forment un SPRITE joueur (la fusée) : Pour le SPRITE 1, les 2 lignes suivantes qui donnent la forme suivante pour l\u0026rsquo;ennemi : Pour le SPRITE 2, les 2 dernières lignes qui donnent la forme suivante pour le tir :\nDu coup, tout devient simple:\n On dit à HL de se charger (via l\u0026rsquo;instruction \u0026lsquo;LD\u0026rsquo;) en allant chercher les données que l\u0026rsquo;on a mis en fin de code dont le label est donnee.\n On charge en DE le début de l\u0026rsquo;adresse de la TGS (je vous ai dit dans un des premiers articles qu\u0026rsquo;elle débutait à 14336 en SCREEN 1).\n On charge en BC la longueur du bloc \u0026lsquo;donnee\u0026rsquo;\n On exécute CALL 92 qui fera le boulot vu qu\u0026rsquo;on lui a donné les entrants.  CHARGEMENT DE LA TAS ;------------------- ; Charge la TAS avec les attributs des 3 sprites (registre 5) ; Registre 5 =\u0026gt; valeur x 128 = Début de l'adresse de la TAS ;------------------- ld c,5 ; registre 5 gère l'adresse de début de la TAS ld b,54 ; valeur 54 = positionne début de la TAS à l'adresse 6912 call 71 ; WRTVDP Ecrire dans le VDP (VRAM) ld hl,donne1 ; va chercher les données TAS au label: donne1 ld de,6912 ; adresse du début de la TAS ld bc,12 ; longueur du bloc = 4 données pour chaque sprite (3 sprites) call 92 ; LIDRVM transfert de bloc de la RAM vers la VRAM  J\u0026rsquo;y ai intégré un petit exercice de manière à progresser au fur et à mesure du code :\nJe vous ai dit qu\u0026rsquo;en SCREEN 1 la table des attributs de SPRITE (TAS) débutait à l\u0026rsquo;adresse 6912. Sur MSX on pourrait changer cette adresse pour diverses raisons (et d\u0026rsquo;ailleurs, ces adresses de tables sont succeptibles de changer en fonction des modes SCREEN que l\u0026rsquo;on utilise).\nAdmettons que l\u0026rsquo;on ne sait pas si la TAS est bien positionnée pour débuter à 6912. Je vous ai expliqué précédemment qu\u0026rsquo;en VRAM, il existait des tables et des registres, et bien chaque table est gérée via un de ces registres.\n Pour notre TAS c\u0026rsquo;est le registre 5.\n Toute valeur que l\u0026rsquo;on écrira dans ce registre sera automatiquement multipliée par 128 et définira l\u0026rsquo;adresse de début de la table TAS. Donc pour obtenir 6912, on le divise par 128 et cela donne 54.\n Finalement, pour définir la TAS à 6912, il suffit d\u0026rsquo;écrire dans le registre 5 la valeur 54.\n C\u0026rsquo;est l\u0026rsquo;objet des 3 premières lignes du code ci-dessus jusqu\u0026rsquo;au CALL 71 (ou 47 en hexa) qui est la routine BIOS qui existe pour écrire dans les registres du VDP :\n WRTVDP\nAddress : #0047\nFunction : write data in the VDP-register\nInput : B - data to write\nC - number of the register\nRegisters: AF, BC\n Fin de l\u0026rsquo;exercice.\nPassons au chargement de la TAS : d\u0026rsquo;abord la procédure va ressembler au PUTSPRITE du BASIC MSX donc cela devrait vous paraître simple et ensuite on va procéder au codage assembleur de la même manière que pour la TGS.\nOn va donner 4 infos pour chaque SPRITE créé :\n La position verticale du SPRITE à l\u0026rsquo;écran\n La position horizontale du SPRITE à l\u0026rsquo;écran\n Le numéro du SPRITE\n La couleur du SPRITE  Mais avant de décrire le bout de code, il faut préciser une particularité importante des SPRITES, ils ne se localisent pas comme les caractères (32 colonnes sur 24 lignes) mais sur des coordonnées plus fines.\nEn SCREEN 1 c\u0026rsquo;est 256 pixels sur 192 pixels :\nDu coup, on va pas trop s\u0026rsquo;attarder sur la méthode car c\u0026rsquo;est la même que pour la TGS et le commentaire associé au code est explicite. On va plutôt détailler le label donne1 associé (que j\u0026rsquo;ai placé au niveau du code, après le label donnee et avant le pied de page).\nRésolution graphique SCREEN 1\n.\ndonne1: db 170,100,0,15 ; Attributs du sprite 0 (position y, x, n°sprite,couleur) db 0,0,1,12 ; Attributs du sprite 1 (position y, x, n°sprite,couleur) db 200,0,2,1 ; Attributs du sprite 2 (position y, x, n°sprite,couleur)  Je vous avais dit qu\u0026rsquo;il y a 4 informations à rentrer par SPRITE dans la TAS.\nDu coup, pour le SPRITE de la 1ere ligne, il aura au 1er affichage à l\u0026rsquo;écran la coordonnée vertical=170 horizontal=100 pour le SPRITE numéro 0 et qui aura la couleur 15 (blanc), vous avez reconnu le sprite joueur/fusée.\nJe vous laisse décrypter les 2 autres lignes pour les 2 autres SPRITES.\nJuste pour finir sur ce code, on voit que l\u0026rsquo;on a 12 données à rentrer, cela tombe bien c\u0026rsquo;est ce que l\u0026rsquo;on charge en BC avant de lancer le CALL 92 qui devient familier pour vous maintenant.\n3 INDICATEURS DE DEPLACEMENT Au début de l\u0026rsquo;article j\u0026rsquo;ai listé le fait que l\u0026rsquo;on allait positionner 3 indicateurs nécessaire au déplacement des sprites. On ne va pas les utiliser de suite mais un minimum d\u0026rsquo;information quand même :\n indcol : un indicateur de collision indbal : un indicateur de balle tirée\n inddir : un indicateur de direction pour l\u0026rsquo;ennemi  Pour que le programme nous autorise à manipuler des valeurs avec ces termes, on doit d\u0026rsquo;abord les déclarer comme suit :\nindcol: EQU 41000 ; défini l'adresse de la variable indcol indbal: EQU 41001 ; défini l'adresse de la variable indbal inddir: EQU 41002 ; défini l'adresse de la variable inddir  Ainsi on dit au programme qu\u0026rsquo;à chaque fois que l\u0026rsquo;on utilisera indcol cela voudra dire en fait que l\u0026rsquo;on sollicite l\u0026rsquo;adresse 41000 de la RAM (un choix arbitraire d\u0026rsquo;adresse libre en RAM). On pourrait traduire EQU par \u0026lsquo;équivaut\u0026rsquo;.\nIdem pour les 2 autres déclarations. ce code je l\u0026rsquo;ai placé dans le bas de page, mais vous pourriez le mettre dans l\u0026rsquo;entête, cela n\u0026rsquo;a pas grande importance.\nEnsuite, je vais assigner des valeurs à ces adresses, pour cela je place le code suivant à la suite du code sur le chargement de la TAS puisque cela fait partie de l\u0026rsquo;initialisation du jeu :\n;------------------------------------------------------------------------------ ; Initialise les 3 variables  ; indcol: indicateur de collision 41000 (adresse) ; indbal: indicateur de balle tirée 41001 (adresse) ; inddir: indicateur de direction de l'ennemi 41002 (adresse) ;------------------------------------------------------------------------------ ld a,1 ld [indcol],a ; indcol = 1 ld [indbal],a ; indbal = 1 ld [inddir],a ; inddir = 1  Rien d\u0026rsquo;exceptionnel, je charge ces pseudo adresses (pour cela, je les passe entre crochets) avec un A qui vaut 1 puisque dans la 1ere ligne j\u0026rsquo;ai assigné 1 à l\u0026rsquo;accumulateur A.\nTAILLE DES SPRITES ;------------------------------------------------------------------------------ ; Taille des sprites agrandis (registre 1) ;------------------------------------------------------------------------------ ld c,1 ; registre 1 gère la talle des sprites ld b,225 ; 225 c'est la valeur pour agrandir un sprite 8 x 8 call 71 ; WRTVDP Ecrire dans le VDP (VRAM)  Sur MSX on peut agir sur la taille des SPRITES, pour cela on utilise le registre 1 de la VRAM qui accepte 4 valeurs possibles :\n SPRITES taille 8 x 8 normal = 224\nSPRITES taille 8 x 8 agrandis = 225\nSPRITES taille 16 x 16 normal = 226\nSPRITES taille 16 x 16 agrandis = 227\n Vu que l\u0026rsquo;on a déclaré dans la TGS des SPRITES de taille 8 x 8, on peut utiliser la valeur 224 ou 225 (vous pouvez vous amuser à changer la valeur pour voir la différence), dans notre jeux on va utiliser 225.\nLe code devrait donc vous parler maintenant : on charge \u0026lsquo;C\u0026rsquo; avec le numéro du registre 1 et \u0026lsquo;B\u0026rsquo; avec la valeur à écrire dans ce registre, ce sont les 2 entrants nécessaires au CALL 71 qui permet d\u0026rsquo;exécuter un ordre d\u0026rsquo;écriture dans un registre VRAM.\nC\u0026rsquo;était le dernier bout de code du label INIT:\nSi on veut voir le résultat il suffit de rajouter une boucle infinie, pour que le programme enchaine dessus après avoir exécuté toutes les actions du INIT:, comme cela par exemple :\nLOOP: jp LOOP  Vous pouvez faire F9 dans CONTEXT, pour lancer la compilation, le fichier généré va s\u0026rsquo;appeler \u0026quot;test1.ROM\u0026quot; et c\u0026rsquo;est celui-là que vous faites glisser dans l\u0026rsquo;émulateur blueMSX.\nVous allez voir apparaître ceci :\nMais où est passé le SPRITE représentant la balle (ou le lazer si vous voulez) ?\nLe premier réflex est de regarder ce que l\u0026rsquo;on a déclaré comme coordonnées pour le SPRITE 2 qui le représente dans la TAS.\nEt que voit-on ? Position verticale = 200\u0026hellip;.alors que la résolution nous permet d\u0026rsquo;aller à un maximum de 191. En le positionnant au delà il disparait dans la bordure de l\u0026rsquo;écran mais il est déjà présent et il sera plus rapide à positionner correctement lorsqu\u0026rsquo;on tirera que si on devait le charger dans la TAS puis calculer sa position au moment du tir.\nSi vous voulez le voir apparaitre et bien jouez avec ses coordonnées, compilez et essayez votre .ROM dans l\u0026rsquo;émulateur.\nVoici le code complet de cet article :\n; **************************************************************** ; MSX ROM Cartridge Header and Function library ; **************************************************************** FNAME \"test1.ROM\" cpu z80 ORG 4000h INCLUDE \"MSXRom-Include.asm\" db \"AB\" DW INIT DW 0 DW 0 DW 0 DS 6 ;------------------------------------------------------------------------------ ; Démarrage du programme à INIT ;------------------------------------------------------------------------------ INIT: LD A,1 ; 1 pour screen 1 ld [64687],A ; (bios)SCRMOD adresse $FCAF :mode courant de l'ecran call 95 ; (bios) CHGMOD : change le mode l'écran ;------------------------------------------------------------------------------ ; Charge la TGS avec la forme des 3 sprites ;------------------------------------------------------------------------------ ld hl,donnee ; va chercher les données TGS au label: donnee ld de,14336 ; adresse du début de la TGS ld bc,24 ; longueur du bloc = 3 sprites de 8 octets = 24 call 92 ; LIDRVM transfert de bloc de la RAM vers la VRAM ;------------------------------------------------------------------------------ ; Charge la TAS avec les attributs des 3 sprites (registre 5) ; Registre 5 =\u0026gt; valeur x 128 = Début de l'adresse de la TAS ;------------------------------------------------------------------------------ ld c,5 ; registre 5 gère l'adresse de début de la TAS ld b,54 ; valeur 54 = positionne début de la TAS à l'adresse 6912 call 71 ; WRTVDP Ecrire dans le VDP (VRAM) ld hl,donne1 ; va chercher les données TAS au label: donne1 ld de,6912 ; adresse du début de la TAS ld bc,12 ; longueur du bloc = 4 données pour chaque sprite (3 sprites) call 92 ; LIDRVM transfert de bloc de la RAM vers la VRAM ;------------------------------------------------------------------------------ ; Initialise les 3 variables  ; indcol: indicateur de collision 41000 (adresse) ; indbal: indicateur de balle tirée 41001 (adresse) ; inddir: indicateur de direction de l'ennemi 41002 (adresse) ;------------------------------------------------------------------------------ ld a,1 ld [indcol],a ; indcol = 1 ld [indbal],a ; indbal = 1 ld [inddir],a ; inddir = 1 ;------------------------------------------------------------------------------ ; Taille des sprites agrandis (registre 1) ;------------------------------------------------------------------------------ ld c,1 ; registre 1 gère la talle des sprites ld b,225 ; 225 c'est la valeur pour agrandir un sprite 8 x 8 call 71 ; WRTVDP Ecrire dans le VDP (VRAM) LOOP: jp LOOP ;------------------------------------------------------------------------------ ; Les données ;------------------------------------------------------------------------------ donnee: db 24,24,126,126 ; sprite 1 pour la TGS db 255,255,255,0 ; sprite 1 db 60,126,153,255 ; sprite 2 db 102,60,66,36 ; sprite 2 db 24,24,24,24 ; sprite 3 db 24,24,24,24 ; sprite 3 donne1: db 170,100,0,15 ; Attributs du sprite 0 (position x, y,n°sprite,couleur) db 0,0,1,12 ; Attributs du sprite 1 (position x, y,n°sprite,couleur) db 200,0,2,1 ; Attributs du sprite 2 (position x, y,n°sprite,couleur) ;************************************************************************************************** ; Standard Libraries ;************************************************************************************************** INCLUDE \"MSXRom-Lib.asm\" ; intègre la librairie MSX END: EQU $ indcol: EQU 41000 ; défini l'adresse de la variable indcol indbal: EQU 41001 ; défini l'adresse de la variable indbal inddir: EQU 41002 ; défini l'adresse de la variable inddir ;************************************************************************************************** ; RAM Definitions ;************************************************************************************************** ;------------------- ; Définit que le programme démarrera au début de la RAM disponible ;------------------- ORG RAMSTART  "
},
{
	"uri": "/tuto-asm-01/09/09-deplacement/",
	"title": "09-Déplacement du joueur",
	"tags": [],
	"description": "",
	"content": " Maintenant que les SPRITES sont affichés, on va commencer à faire bouger la fusée du joueur.\nPour cela on va un peu modifier la structure du code assembleur. Il y surement d\u0026rsquo;autres méthodes, mais c\u0026rsquo;est celle présentée par le livre, donc je l\u0026rsquo;ai suivi.\nJusqu\u0026rsquo;à présent la ROM démarre et appelle tout de suite le sous-programme INIT. Pourquoi ? Ben, parce qu\u0026rsquo;on l\u0026rsquo;a spécifié dans l\u0026rsquo;entête du code, souvenez vous le DW INIT :\n; **************************************************************** ; MSX ROM Cartridge Header and Function library ; **************************************************************** FNAME \"test1.ROM\" cpu z80 ORG 4000h INCLUDE \"MSXRom-Include.asm\" db \"AB\" DW INIT DW 0 DW 0 DW 0 DS 6  Bon et bien maintenant on ne veut pas simplement faire une initialisation (accéder au SCREEN 1 et afficher les SPRITES), on veut installer une partie de code qui va devenir le programme principal, c\u0026rsquo;est par lui que la ROM va débuter.\nC\u0026rsquo;est encore lui qui va se charger d\u0026rsquo;initialiser l\u0026rsquo;affichage la première fois, et qui ensuite, va continuellement surveiller le clavier (via une boucle infinie) et appeler momentanément des sous-programmes de déplacement en fonction de la touche qu\u0026rsquo;il a détecté.\nBon, on va mieux visualiser par un schéma :\nAinsi la ROM ne va plus appeler INIT mais un label que j\u0026rsquo;appelle DEBUT qui va se charger d\u0026rsquo;appeler le sous-programme (ou routine) INIT. Ensuite DEBUT se termine et donne la main à un nouveau label (ou étiquette) qui s\u0026rsquo;appelle BOUCLE (c\u0026rsquo;est notre boucle sans fin) qui va tourner en boucle justement en appelant une routine de temporisation (qui ralenti l\u0026rsquo;affichage écran) et qui surveille le clavier.\nSi pendant cette boucle infinie, une touche directionnelle est enfoncée alors on fait appel à la routine de déplacement de la fusée.\nTous les sous-programmes sont codés de façon à retourner au programme principal une fois leur boulot exécuté.\nVoilà à quoi va ressembler notre programme principal:\nDans l\u0026rsquo;article précédent nous avons déjà codé la routine INIT: (INITIALISATION), Il reste à coder le programme principal, les routines de temporisation et de déplacement. Mais avant, modifions notre entête pour que la ROM lance DEBUT au démarrage et non plus INIT :\n; **************************************************************** ; MSX ROM Cartridge Header and Function library ; **************************************************************** FNAME \"test2.ROM\" cpu z80 ORG 4000h INCLUDE \"MSXRom-Include.asm\" db \"AB\" DW DEBUT ; la ROM lance le sous-programme DEBUT au démarrage DW 0 DW 0 DW 0 DS 6  PROGRAMME PRINCIPAL - DEBUT Je vous livre le code par morceaux, ne vous occupez pas de savoir où le placer dans le fichier, je vous ferai une copie intégrale du code à la fin pour que vous voyez l\u0026rsquo;organisation.\n;------------------------------------------------------------------------------ ; Boucle du jeu : Le programme démarre à DEBUT puis va à BOUCLE ;------------------------------------------------------------------------------ DEBUT: ; c'est ici que débute le programme !!! call INIT ; on appelle le sous-prog INIT  Rien de plus simple pour commencer. Vous remarquez qu\u0026rsquo;il n\u0026rsquo;y a pas d\u0026rsquo;instruction ret (RETURN) à la fin de cette routine. Ainsi le code va continuer au label déclaré juste en dessous puisqu\u0026rsquo;il n\u0026rsquo;est pas arrêté ni re-routé. Ca tombe bien puisque le prochain label que l\u0026rsquo;on va déclarer ensuite est BOUCLE\nPROGRAMME PRINCIPAL - BOUCLE BOUCLE: ; c'est la boucle principale du programme !!! call DELAI ; on appelle le sous-prog DELAI afin de ralentir l'exécution ld a,8 ; on teste la touche gauche = ligne 8 de la matrice du clavier call 321 ; (bios) SNSMAT retourne dans la valeur de la ligne 8 bit 4,a ; bit teste la colonne 4 (0=pressé 1=non pressé) call z,FUSGAU ; si résultat=0 on va au sous-prog FUSGAU (déplacer à droite) call DELAI ; on ralenti l'exécution ld a,8 ; la touche droite est aussi sur la ligne 8 de la matrice call 321 ; on appelle le bios pour qu'il donne la valeur de la ligne 8 bit 7,a ; la colonne 7 est testée (0=pressé 1=non pressé) call z,FUSDRO ; si résultat=0 on va au sous-prog FUSDRO (déplacer àgauche) call DELAI ; on ralenti l'exécution jp BOUCLE ; on redémarre la boucle principale  C\u0026rsquo;est bien le coeur du programme et il va tourner en boucle (comme son label l\u0026rsquo;indique), d\u0026rsquo;ailleurs la dernière ligne de cette partie du code se termine par un JP BOUCLE : Saute au début du label BOUCLE:.\nVoici ce que fait la boucle :\n Appelle une routine DELAI. Verifie si la touche gauche est enfoncée, si tel est le cas, elle appelle la routine de déplacement du sprite vers la gauche FUSGAU. Cette routine lui rendra la main à la fin. Appelle la routine DELAI. Verifie si la touche droite est enfoncée, si tel est le cas, elle appelle la routine de déplacement du sprite vers la droite FUSDRO. Cette routine lui rendra la main à la fin. Appelle la routine DELAI. Retourne au début de la boucle.  0n voit déjà que l\u0026rsquo;on aura 3 routines à écrire par la suite :\n-Routine DELAI\n- Routine FUSGAU\n- Routine FUSDRO\nMais revenons à notre boucle pour l\u0026rsquo;instant. On voit qu\u0026rsquo;après avoir appelé la routine DELAI, on vérifie l\u0026rsquo;enfoncement de la touche gauche, comment ça marche ?\nEn fait, on se base sur une matrice de clavier et une instruction du BIOS qui surveille cette matrice :\nMATRICE CLAVIER\nEt l\u0026rsquo;instruction SNSMAT du BIOS c\u0026rsquo;est le CALL 321 (ou call 141 en hexa) :\n SNSMAT\nAddress : #0141\nFunction : Returns the value of the specified line from the keyboard matrix\nInput : A - for the specified line\nOutput : A - for data (the bit corresponding to the pressed key will be 0)\nRegisters: AF\n Cette instruction BIOS nous dit : Donnez-moi dans A la ligne qui vous intéresse, et je vous charge dans A les infos des bit0 à 7 de cette ligne.\nNous on veut la touche gauche, elle correspond à la ligne 8, donc si on charge A avec 8 et qu\u0026rsquo;on appelle la routine, on récupère toutes les infos de cette ligne dans A.\nLa touche gauche c\u0026rsquo;est le bit 4 (colonnes de la matrice), l\u0026rsquo;instruction BIOS nous dit que si la touche est enfoncée alors le bit correspondant égale 0.\nld a,8 ; on teste la touche gauche = ligne 8 de la matrice du clavier call 321 ; (bios) SNSMAT retourne dans la valeur de la ligne 8 bit 4,a ; bit teste la colonne 4 (0=pressé 1=non pressé) call z,FUSGAU ; si résultat=0 on va au sous-prog FUSGAU (déplacer à droite)  C\u0026rsquo;est exactement ce que l\u0026rsquo;on fait avec BIT 4,A : on teste A avec bit 4 et la ligne suivante on appelle la routine FUSGAU si A est à zéro call z,FUSGAU.\nJe vous laisse chercher pour le curseur à droite et l\u0026rsquo;appel à la routine correspondante.\nDELAI Cette routine permet de ralentir le déplacement de la fusée entre autre sinon cela irait trop vite et on ne verrait pas notre fusée se déplacer de façon douce.\nCe n\u0026rsquo;est rien d\u0026rsquo;autre qu\u0026rsquo;une boucle qui va compter de 255 à 0 sans rien faire d\u0026rsquo;autre avant de rendre la main au programme principal.\nCette routine a 2 labels:\n Le label DELAI, qui est initialisation du compteur à 255 passe le relai au label DEL qui va faire le travail de comptage.\n Le label DEL va décrémenter A d\u0026rsquo;une unité DEC A, si A n\u0026rsquo;égale pas zéro (NZ=Non Zéro) alors on revient au début de DEL\n Si A=0 alors on ne fait plus de JUMP (puisque le résultat n\u0026rsquo;est pas vérifié) mais on fait un retour au programme qui l\u0026rsquo;a appelé (programme principal) via un RET (return).  ;------------------------------------------------------------------------------ ; DELAI ;------------------------------------------------------------------------------ DELAI: ld a,255 ; c'est la valeur de départ, plus elles est haute, plus c'est lent ; a ne peut contenir qu'une valeur entre 0 et 255 DEL: dec a ; c'est la boucle qui va décrémenter de 1 jusqu'à a=0 jp nz,DEL ; si a n'est pas égale à 0 on repart au début de la boucle ret ; si a=0 on retourne au programme principal  Vous pourrez vous amuser à changer la valeur 255 par 1 pour voir le résultat.\nFUSGAU ;------------------------------------------------------------------------------ ; Déplacement de la fusée à gauche ;------------------------------------------------------------------------------ FUSGAU: ld hl,6913 ; récupère adresse de la position x du sprite dans la TAS call 74 ; la fonction charge la valeur de l'adresse dans A donc x=A dec a ; on teste A en le décrementant d'une unité x-1 ret z ; si le résultat de l'opération x=0 on ne fait rien ; et on quitte la sous-routine ; car cela veut dire que la fusée est à la limite de l'écran à gauche call 77 ; sinon on charge la position x de la TAS avec la nouvelle valeur x-1 ret ; on retourne au programme principal  Quand on arrive dans cette routine c\u0026rsquo;est que la touche gauche a été enfoncée.\nDonc on va devoir déplacer notre fusée vers la gauche d\u0026rsquo;un pixel. Pour cela il nous faut la coordonnée horizontale de notre fusée.\nRien de plus simple, quand on a chargé les attributs des sprites dans la TAS, on a commencée à les enregistrer à l\u0026rsquo;adresse 6912 (début de la TAS) et en plus le 1er sprite pour lequel on a chargé les infos (4 données: position y, position x, numéro de sprite, couleur) c\u0026rsquo;est notre fusée. Donc les données de notre sprite sont aux adresses suivantes :\n Adresse 6912 : position y\n Adresse 6913 : position x\n Adresse 6914 : numéro du sprite\n Adresse 6915 : couleur du sprite\n  Et ainsi de suite pour les sprites suivants (vous devriez donc connaître les coordonées du sprite ennemi\u0026hellip;en tout cas leurs adresses).\nDans notre cas, la fusée, on sait que la position x est à l\u0026rsquo;adresse 6913.\nIl suffit donc de l\u0026rsquo;appeler, de faire des calculs sur la valeur x et de la recharger dans la TAS pour que notre sprite prenne en compte la nouvelle position.\nPour lire la valeur d\u0026rsquo;une adresse de la VRAM on fait un CALL 74 (CALL 4A) qui chargera la valeur dans l\u0026rsquo;accumulateur A :\n RDVRM\nAddress : #004A\nFunction : Reads the content of VRAM\nInput : HL - address read\nOutput : A - value which was read\nRegisters: AF\n On soustrait 1 unité, et oui pour aller à gauche on revient vers la coordonnée 0 de l\u0026rsquo;écran. On retourne au programme principale sans rien faire si A=0 (RET Z) car cela veut dire que l\u0026rsquo;on est déjà à l\u0026rsquo;extrémité gauche de l\u0026rsquo;écran. Sinon on continue dans le code, on a déjà décrémenté A, donc il nous reste plus qu\u0026rsquo;à écrire à l\u0026rsquo;adresse chargée dans l\u0026rsquo;accumulateur HL la nouvelle valeur via un CALL 77 (CALL 4D) :\n WRTVRM\nAddress : #004D\nFunction : Writes data in VRAM\nInput : HL - address write\nA - value write\nRegisters: AF\n Et on retourne au programme principal (RET).\nFUSDRO C\u0026rsquo;est pareil que pour la routine précédente. Seul change le test de l\u0026rsquo;extrémité de l\u0026rsquo;écran à droite qui est fixé à 240 (240+ 16 pixels de notre sprite =256\u0026hellip;..un sprite de 8 mais agrandi x 2).\n;------------------------------------------------------------------------------ ; Déplacement de la fusée droite ;------------------------------------------------------------------------------ FUSDRO: ld hl,6913 ; récupère adresse de la position x du sprite dans la TAS call 74 ; la fonction charge la valeur de l'adresse dans A donc x=A SUB 240 ; on teste A en lui enlevant 240 ret z ; si le résultat de l'opération=0 on ne fait rien  ; et on quitte la sous-routine ; car cela veut dire que la fusée est à la limite de l'écran à droite add a,241 ; rajoute les 240 pour retrouver le x initial et incrémente de 1(donc 241) call 77 ; sinon on charge la position x de la TAS avec la nouvelle valeur x+1 ret ; on retourne au programme principal  Comme pour l\u0026rsquo;instant on pratique des calculs qui nous permettent de comparer à 0 ou non 0 , pour vérifier si x est déjà à 240, il suffit de luis soustraire 240 et de comparer à 0, sinon on lui rajoute les 240 pour le ramener à l\u0026rsquo;état dans lequel on la récupéré et on lui rajoute 1 pour qu\u0026rsquo;il se déplace à droite. Ce code devrait s\u0026rsquo;abstenir de plus de commentaires désormais.\nJe vous livre le code en entier pour que vous voyez l\u0026rsquo;ordre des routines insérées bien qu\u0026rsquo;il n\u0026rsquo;y ait pas grande importance (sauf pour celles où on n\u0026rsquo;a pas mis de RET pour qu\u0026rsquo;elles enchaînent sur le prochain label en dessous, ex :DEBUT et BOUCLE) puisqu\u0026rsquo;une fois la ROM démarrée, elle va appeler la routine \u0026lsquo;DEBUT\u0026rsquo; et les sauts vont s\u0026rsquo;enchaîner comme on l\u0026rsquo;a codé. Compilez, jouez vous devriez pouvoir déplacer votre fusée :\n; **************************************************************** ; MSX ROM Cartridge Header and Function library ; **************************************************************** FNAME \"test2.ROM\" cpu z80 ORG 4000h INCLUDE \"MSXRom-Include.asm\" db \"AB\" DW DEBUT ; la ROM lance le sous-programme DEBUT au démarrage DW 0 DW 0 DW 0 DS 6 ;------------------------------------------------------------------------------ ; Iinitialisation, appelé par le début du programme : DEBUT ;------------------------------------------------------------------------------ INIT: LD A,1 ; 1 pour screen 1 ld [64687],A ; (bios)SCRMOD adresse hexa $FCAF :mode courant de l'ecran call 95 ; (bios)CHGMOD : change le mode l'écran ;------------------------------------------------------------------------------ ; Charge la TGS avec la forme des 3 sprites ;------------------------------------------------------------------------------ ld hl,donnee ; charge les données TGS via le label: donnee ld de,14336 ; adresse du début de la TGS ld bc,24 ; longueur du bloc = 3 sprites de 8 octets = 24 call 92 ; LIDRVM transfert de bloc de la RAM vers la VRAM ;------------------------------------------------------------------------------ ; Charge la TAS avec les attributs des 3 sprites (registre 5) ; Registre 5 =\u0026gt; valeur x 128 = Début de l'adresse de la TAS ;------------------------------------------------------------------------------ ld c,5 ; registre 5 gère l'adresse de début de la TAS ld b,54 ; valeur 54 = positionne début de la TAS à l'adresse 6912 call 71 ; WRTVDP Ecrire dans le VDP (VRAM) ld hl,donne1 ; charge les données TAS au label: donne1 ld de,6912 ; adresse du début de la TAS ld bc,12 ; longueur du bloc = 4 données pour chaque sprite (3 sprites) call 92 ; LIDRVM transfert de bloc de la RAM vers la VRAM ;------------------------------------------------------------------------------ ; Initialise les 3 variables  ; indcol: indicateur de collision adresse 41000 ; indbal: indicateur de balle tirée adresse 41001 ; inddir: indicateur de direction de l'ennemi adresse 41002 ;------------------------------------------------------------------------------ ld a,1 ld [indcol],a ; indcol = 1 ld [indbal],a ; indbal = 1 ld [inddir],a ; inddir = 1 ;------------------------------------------------------------------------------ ; Taille des sprites agrandis (registre 1) ;------------------------------------------------------------------------------ ld c,1 ; registre 1 gère la taille des sprites ld b,225 ; 225 c'est la valeur pour agrandir un sprite 8 x 8 call 71 ; WRTVDP Ecrire dans un registre du VDP (VRAM) ;------------------------------------------------------------------------------ ; Positionne l'adresse de début de la TNP (registre 2) ; Registre 2 =\u0026gt; valeur x 1024 = Début de l'adresse de la TNP ;------------------------------------------------------------------------------ ld c,2 ; registre 2 ld b,6 ; valeur 6 = positionne début de la TNP à l'adresse 6144 call 71 ; WRTVDP Ecrire dans un registre du VDP (VRAM) ret ; fin de la boucle INIT ;------------------------------------------------------------------------------ ; Déplacement de la fusée à gauche ;------------------------------------------------------------------------------ FUSGAU: ld hl,6913 ; récupère adresse de la position x du sprite dans la TAS call 74 ; la fonction charge la valeur de l'adresse dans A donc x=A dec a ; on teste A en le décrementant d'une unité x-1 ret z ; si le résultat de l'opération x=0 on ne fait rien ; et on quitte la sous-routine ; car cela veut dire que la fusée est à la limite de l'écran à gauche call 77 ; sinon on charge la position x de la TAS avec la nouvelle valeur x-1 ret ; on retourne au programme principal ;------------------------------------------------------------------------------ ; Déplacement de la fusée droite ;------------------------------------------------------------------------------ FUSDRO: ld hl,6913 ; récupère adresse de la position x du sprite dans la TAS call 74 ; la fonction charge la valeur de l'adresse dans A donc x=A SUB 240 ; on teste A en lui enlevant 240 ret z ; si le résultat de l'opération=0 on ne fait rien  ; et on quitte la sous-routine ; car cela veut dire que la fusée est à la limite de l'écran à droite add a,241 ; rajoute les 240 pour retrouver le x initial et incrémente de 1(donc 241) call 77 ; sinon on charge la position x de la TAS avec la nouvelle valeur x+1 ret ; on retourne au programme principal ;------------------------------------------------------------------------------ ; DELAI ;------------------------------------------------------------------------------ DELAI: ld a,255 ; c'est la valeur de départ, plus elles est haute, plus c'est lent ; a ne peut contenir qu'une valeur entre 0 et 255 DEL: dec a ; c'est la boucle qui va décrémenter de 1 jusqu'à a=0 jp nz,DEL ; si a n'est pas égale à 0 on repart au début de la boucle ret ; si a=0 on retourne au programme principal ;------------------------------------------------------------------------------ ; Boucle du jeu : Le programme démarre à DEBUT puis va à BOUCLE ;------------------------------------------------------------------------------ DEBUT: ; c'est ici que débute le programme !!! call INIT ; on appelle le sous-prog INIT BOUCLE: ; c'est la boucle principale du programme !!! call DELAI ; on appelle le sous-prog DELAI afin de ralentir l'exécution ld a,8 ; on teste la touche gauche = ligne 8 de la matrice du clavier call 321 ; (bios) SNSMAT retourne dans la valeur de la ligne 8 bit 4,a ; bit teste la colonne 4 (0=pressé 1=non pressé) call z,FUSGAU ; si résultat=0 on va au sous-prog FUSGAU (déplacer à droite) call DELAI ; on ralenti l'exécution ld a,8 ; la touche droite est aussi sur la ligne 8 de la matrice call 321 ; on appelle le bios pour qu'il donne la valeur de la ligne 8 bit 7,a ; la colonne 7 est testée (0=pressé 1=non pressé) call z,FUSDRO ; si résultat=0 on va au sous-prog FUSDRO (déplacer àgauche) call DELAI ; on ralenti l'exécution jp BOUCLE ; on redémarre la boucle principale ;------------------------------------------------------------------------------ ; Les données ;------------------------------------------------------------------------------ donnee: db 24,24,126,126 ; sprite 1 pour la TGS db 255,255,255,0 ; sprite 1 \" \" db 60,126,153,255 ; sprite 2 \" \" db 102,60,66,36 ; sprite 2 \" \" db 24,24,24,24 ; sprite 3 \" \" db 24,24,24,24 ; sprite 3 \" \" donne1: db 170,100,0,15 ; Attributs du sprite 0 (position y, x, n°sprite,couleur) db 0,0,1,12 ; Attributs du sprite 1 (position y, x, n°sprite,couleur) db 200,0,2,1 ; Attributs du sprite 2 (position y, x, n°sprite,couleur) ;************************************************************************************************** ; Standard Libraries ;************************************************************************************************** INCLUDE \"MSXRom-Lib.asm\" ; intègre la librairie MSX END: EQU $ indcol: EQU 41000 ; défini l'adresse de la variable indcol (registre des collisions) indbal: EQU 41001 ; défini l'adresse de la variable indbal inddir: EQU 41002 ; défini l'adresse de la variable inddir ;************************************************************************************************** ; RAM Definitions ;************************************************************************************************** ;------------------- ; Définit que le programme démarrera au début de la RAM disponible ;------------------- ORG RAMSTART  "
},
{
	"uri": "/tuto-asm-01/10/10-envahisseur/",
	"title": "10-Déplacement de l&#39;envahisseur",
	"tags": [],
	"description": "",
	"content": "On le sait tous, un extra-terrestre c\u0026rsquo;est bête à manger du foin, donc on va lui créer une intelligence artificielle (IA) limitée\u0026hellip;\nen fait, on va faire déplacer l\u0026rsquo;ennemi de façon autonome mais simple et de plus, l\u0026rsquo;exemple du livre ne va pas plus loin, donc\u0026hellip;.on va dire que c\u0026rsquo;est moi qui suis limité ;-)\nOn va utiliser une des variables que l\u0026rsquo;on a déclaré précédemment et qui s\u0026rsquo;appelle inddir (comme \u0026lsquo;indicateur de direction\u0026rsquo;), je vous rappelle ce que l\u0026rsquo;on avait fait pour ces variables :\nindcol: EQU 41000 ; défini l'adresse de la variable indcol (registre des collisions) indbal: EQU 41001 ; défini l'adresse de la variable indbal inddir: EQU 41002 ; défini l'adresse de la variable inddir  On les a d\u0026rsquo;abord déclaré comme associées à une adresse spécifique de la mémoire RAM dans le pied de page de notre code , pour inddir c\u0026rsquo;était une adresse très lointaine dans la mémoire qui nous permet d\u0026rsquo;espérer qu\u0026rsquo;elle ne se fera pas écraser par du code, ici l\u0026rsquo;adresse 41002.\nDe ce fait on pourra stocker n\u0026rsquo;importe quelle valeur dedans et la modifier au besoin.\nCet indicateur, on va le manipuler pour le faire passer d\u0026rsquo;une valeur 0 à 1 (et inversement).\nDans l\u0026rsquo;un des articles précédent on a déclaré inddir à l\u0026rsquo;adresse 41002 mais on a stocké une valeur dedans qui était 1, un petit rappel de la manière dont on a procédé dans le code : ;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; ; Initialise les 3 variables  ; indcol: indicateur de collision adresse 41000 ; indbal: indicateur de balle tirée adresse 41001 ; inddir: indicateur de direction de l\u0026rsquo;ennemi adresse 41002 ;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; ld a,1 ld [indcol],a ; indcol = 1 ld [indbal],a ; indbal = 1 ld [inddir],a ; inddir = 1 \nLa stratégie va être que dans la boucle principale du programme, on va appeler une fois par boucle la routine de déplacement de l\u0026rsquo;ennemi.\nAvant de le déplacer, on va aller consulter la valeur de cet indicateur :\n s\u0026rsquo;il est à 1 on appellera une routine pour le déplacer de droite à gauche, s\u0026rsquo;il est à 0 on appellera une routine qui le déplace de gauche à droite.  Mais ce n\u0026rsquo;est pas tout, avant d\u0026rsquo;incrémenter le déplacement dans les sous-routine on vérifiera que la valeur de la coordonnée (ici, X) n\u0026rsquo;a pas atteint une extrémité de l\u0026rsquo;écran.\nSi c\u0026rsquo;est le cas, on va aller changer la valeur de l\u0026rsquo;indicateur à l\u0026rsquo;adresse 41002 pour qu\u0026rsquo;il se déplace dans l\u0026rsquo;autre sens à la prochaine boucle et ce, jusqu\u0026rsquo;à l\u0026rsquo;extrémité opposée. un petit schéma : Pourquoi x=240 à droite alors que la résolution va jusqu\u0026rsquo;à 256 ?\n\rEn fait les coordonnées des sprites correspondent au premier pixel en haut à gauche de chaque sprite.\nNos sprites étant agrandis à une taille x2, ils font 16 pixels sur 16 pixels, donc quand notre sprite est à la coordonnée x=240, entre 240 et 256 ce sont les 16 pixels de l\u0026rsquo;envahisseur qui s\u0026rsquo;affichent.\n Si on décidait d\u0026rsquo;aller au-delà le sprite sortirait de l\u0026rsquo;écran car il a besoin de 16 pixels à droite pour apparaître.\n Je vais d\u0026rsquo;abord vous décrire l\u0026rsquo;algorithme choisi pour le déplacement (qui commence par la routine DEPENV) et ensuite on rentrera dans le code : On a donc 4 routines à écrire :\n DEPENV (comme \u0026lsquo;déplacement envahisseur\u0026rsquo;)\n ENDRO1 (envahisseur droite)\n ENGAU (envahisseur à gauche)\n ENGAU1 (sous routine envahisseur à gauche)  Dans la boucle principale du programme on appellera la routine DEPENV qui dispatchera le travail entre les sous-routines en fonction de l\u0026rsquo;état de l\u0026rsquo;indicateur inddir et de l\u0026rsquo;état de la valeur de la coordonnée X du sprite envahisseur.\nPassons au code que l\u0026rsquo;on rajoute en dessous de la routine DELAI (mais on pourrait le mettre ailleurs vu qu\u0026rsquo;on utilise des labels pour les appeler) :\n;------------------------------------------------------------------------------ ; Déplacement de l'envahisseur / Gestion de la direction de l'envahisseur ; indir=1 : de droite à gauche / indir=0 : de gauche à droite ;------------------------------------------------------------------------------ DEPENV: ld a,[inddir] ; on charge en a la valeur de l'indicateur de direction dec a ; on décremente a pour vérifier si indir=1 jp z,ENGAU ; si a=0 c'est que inddir valait 1,on va au sous-prog ENGAU (à gauche) ld hl,6917 ; sinon on récupère adresse de la position x du sprite dans la TAS call 74 ; la fonction récupère la valeur de l'adresse dans A donc x=A sub 240 ; on elève 240 à a jp nz,ENDRO1 ; si le résultat n'égale pas 0 alors on va en ENDRO1 (à droite) ld a,1 ; sinon on est au bord droit de l'écran et on change l'indicateur ld [inddir],a ; on charge l'indicateur avec la nouvelle direction (1) ret  La 1ere chose que fait la routine DEPENV, c\u0026rsquo;est de vérifier la valeur de l\u0026rsquo;indicateur inddir, s\u0026rsquo;il vaut 1 c\u0026rsquo;est que l\u0026rsquo;envahisseur doit se déplacer vers la gauche (0 vers la droite), il suffit de faire un calcul sur la valeur de l\u0026rsquo;inddir.\nIci on lui soustrait 1 :\n si le résultat est égale à 0 c\u0026rsquo;est que inddir=1 quand on l\u0026rsquo;a appelé, dans ce cas on appelle la sous-routine ENGAU qui gère ce type de déplacement.\n sinon (inddir=0 car 0-1 n\u0026rsquo;égale pas 0) on récupère le X du sprite envahisseur à l\u0026rsquo;adresse correspondante.  la TAS abrite ces informations, elle débute à 6912 et il faut 4 adresses pour chaque sprites, donc pour l\u0026rsquo;envahisseur c\u0026rsquo;est 6917 qui abrite la valeur du X\u0026hellip;.\n\u0026hellip;bon allez, je vous fais un petit rappel de ce qu\u0026rsquo;on a rentré dans la TAS pour ces SPRITES :\nDonc on récupère la valeur de la coordonnée X du sprite, comme on compare avec zéro ou pas zéro, pour vérifier si X=240, il suffit de faire un calcul dessus, si tel n\u0026rsquo;est pas le cas alors la sous-routine ENDRO1 fera le boulot de déplacement vers la droite.\nSi par contre on est déjà à l\u0026rsquo;extrème droite de l\u0026rsquo;écran, on ne fait que changer la valeur de inddir pour qu\u0026rsquo;à la prochaine boucle l\u0026rsquo;envahisseur se déplace vers la gauche.\nJe vous donne les autres sous-routines, elles sont maintenant simples à comprendre :\n;------------------------------------------------------------------------------ ; Déplacement de l'envahisseur vers la droite ;------------------------------------------------------------------------------ ENDRO1: ld hl,6917 ; on récupère adresse de la position x du sprite dans la TAS call 74 ; la fonction récupère la valeur de l'adresse dans A donc x=A inc a ; on incrémente a pour déplacer de 1 à droite (x+1) call 77 ; on charge la position x de la TAS avec le x+1 ret ; on retourne au programme principal ;------------------------------------------------------------------------------ ; Changement de direction (0) si l'envahisseur est arrivé au bord gauche x=0 ;------------------------------------------------------------------------------ ENGAU: ld hl,6917 ; on récupère adresse de la position x du sprite dans la TAS call 74 ; la fonction récupère la valeur de l'adresse dans A donc x=A SUB 1 ; on enlève 1 à a (x-1) jp nz,ENGAU1 ; si maintenant n'est pas égale à 0 on va en ENGAU1 ld a,0 ; sinon on est au bord gauche de l'écran et on change l'indicateur ld [inddir],a ; on charge l'indicateur avec la nouvelle direction (0) ret ;------------------------------------------------------------------------------ ; Déplacement de l'envahisseur vers la gauche ;------------------------------------------------------------------------------ ENGAU1: ld hl,6917 ; on récupère adresse de la position x du sprite dans la TAS call 74 ; la fonction récupère la valeur de l'adresse dans A donc x=A dec a ; on décrémente a pour déplacer de 1 à gauche (x-1) call 77 ; on charge la position x de la TAS avec le x+1 ret ; on retourne au programme principal  Ce code est à ajouter en dessous de la routine DEPENV.\nElles sont simple à comprendre, surtout avec le schéma de l\u0026rsquo;algorithme que je vous ai fait plus haut. La seule subtilité c\u0026rsquo;est les routines qui ont pour rôle de calculer le prochain déplacement effectif de l\u0026rsquo;envahisseur (ENGAU1 et ENDRO1) finissent par un CALL 77 qui est l\u0026rsquo;instruction qui modifie vraiment la coordonnée X du SPRITE dans la TAS, sans ce CALL 77 les autres calculs que l\u0026rsquo;on a fait étaient sans impact sur la TAS. Ils étaient un peut comme quand l\u0026rsquo;on fait des calculs sur le coin d\u0026rsquo;un cahier de brouillon.\nIl ne nous reste plus qu\u0026rsquo;à rajouter une instruction dans la boucle principale qui appellera le DEPENV et c\u0026rsquo;est CALL DEPENV (c\u0026rsquo;est la ligne 8 du code ci-dessous) :\n;------------------------------------------------------------------------------ ; Boucle du jeu : Le programme démarre à DEBUT puis va à BOUCLE ;------------------------------------------------------------------------------ DEBUT: ; c'est ici que débute le programme !!! call INIT ; on appelle le sous-prog INIT BOUCLE: ; c'est la boucle principale du programme !!! call DEPENV ; on appelle le déplacement de l'envahisseur call DELAI ; on appelle le sous-prog DELAI afin de ralentir l'exécution ld a,8 ; on teste la touche gauche = ligne 8 de la matrice du clavier call 321 ; (bios) SNSMAT retourne dans la valeur de la ligne 8 bit 4,a ; bit teste la colonne 4 (0=pressé 1=non pressé) call z,FUSGAU ; si résultat=0 on va au sous-prog FUSGAU (déplacer à droite) call DELAI ; on ralenti l'exécution ld a,8 ; la touche droite est aussi sur la ligne 8 de la matrice call 321 ; on appelle le bios pour qu'il donne la valeur de la ligne 8 bit 7,a ; la colonne 7 est testée (0=pressé 1=non pressé) call z,FUSDRO ; si résultat=0 on va au sous-prog FUSDRO (déplacer àgauche) call DELAI ; on ralenti l'exécution jp BOUCLE ; on redémarre la boucle principale  Et pour finir le code entier du programme mis à jour qu\u0026rsquo;il ne vous reste plus qu\u0026rsquo;à compiler et lancer dans l\u0026rsquo;émulateur blueMSX : ; **************************************************************** ; MSX ROM Cartridge Header and Function library ; **************************************************************** FNAME \u0026ldquo;test3.ROM\u0026rdquo; cpu z80\nORG 4000h\nINCLUDE \u0026ldquo;MSXRom-Include.asm\u0026rdquo;\ndb \u0026ldquo;AB\u0026rdquo; DW DEBUT ; la ROM lance le sous-programme DEBUT au démarrage DW 0 DW 0 DW 0 DS 6\n;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; ; Iinitialisation, appelé par le début du programme : DEBUT ;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; INIT: Ld a,1 ; 1 pour screen 1 ld [64687],a ; (bios)SCRMOD adresse hexa $FCAF :mode courant de l\u0026rsquo;ecran call 95 ; (bios)CHGMOD : change le mode l\u0026rsquo;écran ;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; ; Charge la TGS avec la forme des 3 sprites ;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; ld hl,donnee ; charge les données TGS via le label: donnee ld de,14336 ; adresse du début de la TGS ld bc,24 ; longueur du bloc = 3 sprites de 8 octets = 24 call 92 ; LIDRVM transfert de bloc de la RAM vers la VRAM ;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; ; Charge la TAS avec les attributs des 3 sprites (registre 5) ; Registre 5 =\u0026gt; valeur x 128 = Début de l\u0026rsquo;adresse de la TAS ;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; ld c,5 ; registre 5 gère l\u0026rsquo;adresse de début de la TAS ld b,54 ; valeur 54 = positionne début de la TAS à l\u0026rsquo;adresse 6912 call 71 ; WRTVDP Ecrire dans le VDP (VRAM) ld hl,donne1 ; charge les données TAS au label: donne1 ld de,6912 ; adresse du début de la TAS ld bc,12 ; longueur du bloc = 4 données pour chaque sprite (3 sprites) call 92 ; LIDRVM transfert de bloc de la RAM vers la VRAM ;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; ; Initialise les 3 variables  ; indcol: indicateur de collision adresse 41000 ; indbal: indicateur de balle tirée adresse 41001 ; inddir: indicateur de direction de l\u0026rsquo;ennemi adresse 41002 ;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; ld a,1 ld [indcol],a ; indcol = 1 ld [indbal],a ; indbal = 1 ld [inddir],a ; inddir = 1 ;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; ; Taille des sprites agrandis (registre 1) ;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; ld c,1 ; registre 1 gère la taille des sprites ld b,225 ; 225 c\u0026rsquo;est la valeur pour agrandir un sprite 8 x 8 call 71 ; WRTVDP Ecrire dans un registre du VDP (VRAM) ;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; ; Positionne l\u0026rsquo;adresse de début de la TNP (registre 2) ; Registre 2 =\u0026gt; valeur x 1024 = Début de l\u0026rsquo;adresse de la TNP ;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; ld c,2 ; registre 2 ld b,6 ; valeur 6 = positionne début de la TNP à l\u0026rsquo;adresse 6144 call 71 ; WRTVDP Ecrire dans un registre du VDP (VRAM) ret ; fin de la boucle INIT\n;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; ; Déplacement de la fusée à gauche ;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; FUSGAU: ld hl,6913 ; récupère adresse de la position x du sprite dans la TAS call 74 ; la fonction charge la valeur de l\u0026rsquo;adresse dans A donc x=A dec a ; on teste A en le décrementant d\u0026rsquo;une unité x-1 ret z ; si le résultat de l\u0026rsquo;opération x=0 on ne fait rien ; et on quitte la sous-routine ; car cela veut dire que la fusée est à la limite de l\u0026rsquo;écran à gauche call 77 ; sinon on charge la position x de la TAS avec la nouvelle valeur x-1 ret ; on retourne au programme principal\n;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; ; Déplacement de la fusée droite ;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; FUSDRO: ld hl,6913 ; récupère adresse de la position x du sprite dans la TAS call 74 ; la fonction charge la valeur de l\u0026rsquo;adresse dans A donc x=A SUB 240 ; on teste A en lui enlevant 240 ret z ; si le résultat de l\u0026rsquo;opération=0 on ne fait rien  ; et on quitte la sous-routine ; car cela veut dire que la fusée est à la limite de l\u0026rsquo;écran à droite add a,241 ; rajoute les 240 pour retrouver le x initial et incrémente de 1(donc 241) call 77 ; sinon on charge la position x de la TAS avec la nouvelle valeur x+1 ret ; on retourne au programme principal\n;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; ; DELAI ;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; DELAI: ld a,255 ; c\u0026rsquo;est la valeur de départ, plus elles est haute, plus c\u0026rsquo;est lent ; a ne peut contenir qu\u0026rsquo;une valeur entre 0 et 255 DEL: dec a ; c\u0026rsquo;est la boucle qui va décrémenter de 1 jusqu\u0026rsquo;à a=0 jp nz,DEL ; si a n\u0026rsquo;est pas égale à 0 on repart au début de la boucle ret ; si a=0 on retourne au programme principal\n;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; ; Déplacement de l\u0026rsquo;envahisseur / Gestion de la direction de l\u0026rsquo;envahisseur ; indir=1 : de droite à gauche / indir=0 : de gauche à droite ;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; DEPENV: ld a,[inddir] ; on charge en a la valeur de l\u0026rsquo;indicateur de direction dec a ; on décremente a pour vérifier si indir=1 jp z,ENGAU ; si a=0 c\u0026rsquo;est que inddir valait 1,on va au sous-prog ENGAU (à gauche) ld hl,6917 ; sinon on récupère adresse de la position x du sprite dans la TAS call 74 ; la fonction récupère la valeur de l\u0026rsquo;adresse dans A donc x=A sub 240 ; on elève 240 à a jp nz,ENDRO1 ; si le résultat n\u0026rsquo;égale pas 0 alors on va en ENDRO1 (à droite) ld a,1 ; sinon on est au bord droit de l\u0026rsquo;écran et on change l\u0026rsquo;indicateur ld [inddir],a ; on charge l\u0026rsquo;indicateur avec la nouvelle direction (1) ret\n;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; ; Déplacement de l\u0026rsquo;envahisseur vers la droite ;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; ENDRO1: ld hl,6917 ; on récupère adresse de la position x du sprite dans la TAS call 74 ; la fonction récupère la valeur de l\u0026rsquo;adresse dans A donc x=A inc a ; on incrémente a pour déplacer de 1 à droite (x+1) call 77 ; on charge la position x de la TAS avec le x+1 ret ; on retourne au programme principal\n;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; ; Changement de direction (0) si l\u0026rsquo;envahisseur est arrivé au bord gauche x=0 ;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; ENGAU: ld hl,6917 ; on récupère adresse de la position x du sprite dans la TAS call 74 ; la fonction récupère la valeur de l\u0026rsquo;adresse dans A donc x=A SUB 1 ; on enlève 1 à a (x-1) jp nz,ENGAU1 ; si maintenant n\u0026rsquo;est pas égale à 0 on va en ENGAU1 ld a,0 ; sinon on est au bord gauche de l\u0026rsquo;écran et on change l\u0026rsquo;indicateur ld [inddir],a ; on charge l\u0026rsquo;indicateur avec la nouvelle direction (0) ret\n;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; ; Déplacement de l\u0026rsquo;envahisseur vers la gauche ;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; ENGAU1: ld hl,6917 ; on récupère adresse de la position x du sprite dans la TAS call 74 ; la fonction récupère la valeur de l\u0026rsquo;adresse dans A donc x=A dec a ; on décrémente a pour déplacer de 1 à gauche (x-1) call 77 ; on charge la position x de la TAS avec le x+1 ret ; on retourne au programme principal\n;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; ; Boucle du jeu : Le programme démarre à DEBUT puis va à BOUCLE ;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\nDEBUT: ; c\u0026rsquo;est ici que débute le programme !!! call INIT ; on appelle le sous-prog INIT BOUCLE: ; c\u0026rsquo;est la boucle principale du programme !!! call DEPENV ; on appelle le déplacement de l\u0026rsquo;envahisseur call DELAI ; on appelle le sous-prog DELAI afin de ralentir l\u0026rsquo;exécution ld a,8 ; on teste la touche gauche = ligne 8 de la matrice du clavier call 321 ; (bios) SNSMAT retourne dans la valeur de la ligne 8 bit 4,a ; bit teste la colonne 4 (0=pressé 1=non pressé) call z,FUSGAU ; si résultat=0 on va au sous-prog FUSGAU (déplacer à droite) call DELAI ; on ralenti l\u0026rsquo;exécution ld a,8 ; la touche droite est aussi sur la ligne 8 de la matrice call 321 ; on appelle le bios pour qu\u0026rsquo;il donne la valeur de la ligne 8 bit 7,a ; la colonne 7 est testée (0=pressé 1=non pressé) call z,FUSDRO ; si résultat=0 on va au sous-prog FUSDRO (déplacer àgauche) call DELAI ; on ralenti l\u0026rsquo;exécution jp BOUCLE ; on redémarre la boucle principale\n;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; ; Les données ;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; donnee: db 24,24,126,126 ; sprite 1 pour la TGS db 255,255,255,0 ; sprite 1 \u0026ldquo; \u0026ldquo; db 60,126,153,255 ; sprite 2 \u0026ldquo; \u0026ldquo; db 102,60,66,36 ; sprite 2 \u0026ldquo; \u0026ldquo; db 24,24,24,24 ; sprite 3 \u0026ldquo; \u0026ldquo; db 24,24,24,24 ; sprite 3 \u0026ldquo; \u0026ldquo; donne1: db 170,100,0,15 ; Fusée joueur sprite 0 (position y, x,n°sprite,couleur) db 0,0,1,12 ; Envahisseur sprite 1 (position y, x,n°sprite,couleur)  db 200,0,2,1 ; Laser fusée sprite 2 (position y, x,n°sprite,couleur)\n;*********************************************************************************************** ; Standard Libraries ;***********************************************************************************************\nINCLUDE \u0026ldquo;MSXRom-Lib.asm\u0026rdquo; ; intègre la librairie MSX\nEND: EQU $ indcol: EQU 41000 ; défini l\u0026rsquo;adresse de la variable indcol (registre des collisions) indbal: EQU 41001 ; défini l\u0026rsquo;adresse de la variable indbal inddir: EQU 41002 ; défini l\u0026rsquo;adresse de la variable inddir\n;*********************************************************************************************** ; RAM Definitions ;***********************************************************************************************\n;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;- ; Définit que le programme démarrera au début de la RAM disponible ;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;- ORG RAMSTART\n \n"
},
{
	"uri": "/tuto-asm-01/11/11-gestiontir/",
	"title": "11-Gestion du tir",
	"tags": [],
	"description": "",
	"content": " Il ne nous reste plus que le tir à implémenter et notre exemple de shoot \u0026lsquo;em up sera terminé.\nLe principe est simple, une fois que la touche ESPACE sera appuyée, on va déclencher le tir et indiquer qu\u0026rsquo;il faut déplacer le laser en activant une variable indbal (indicateur de balle tirée), pendant ce déplacement du laser on va surveiller 2 choses :\n la collision entre le SPRITE de l\u0026rsquo;envahisseur et le SPRITE du laser. le laser qui qui finit sa course sans atteindre l\u0026rsquo;envahisseur.  Dans le cas 1, si le cas arrive c\u0026rsquo;est le déclenchement de l\u0026rsquo;explosion et le jeu recommence.\nDans le cas 2, si cela arrive on remettra on fera disparaitre le laser et on remettra indbal en l\u0026rsquo;état intial pour permettre à nouveau de tirer.\n\rVoici ce que donne l\u0026rsquo;algorithme que l\u0026rsquo;on codera ensuite :\nComme on a initialisé le jeu avec toutes les variables à 1, si la touche espace n\u0026rsquo;est pas appuyée dans la boucle principale du programme, elle ignorera les 2 autres conditions (indbal et indcol égales à zéro).\nFEU Si on appuie sur la touche espace, on déclenche le tir au niveau des coordonnées de la fusée et on change la variable indbal qui servira à :\n déplacer le laser (routine TIRBAL).\n et empêcher un autre tir par la touche espace tant que le premier n\u0026rsquo;est pas finit (routine FEU).  La routine FEU: ;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; ; FEU ; indbal=1 pas de balle tirée / indbal=0 balle tirée ;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; FEU: ld a,[indbal] ; on vérifie la valeur de indbal inc a ; si indbal=0 une balle est déjà en cours dec a ; donc on ne peut pas retirer ret z ; et on quitte la routine ld hl,6913 ; si indbal=1 on récupère la coord X de la fusée call 74 ; via la TAS (lecture) ld hl,6921 ; et on la met sa valeur dans le X du laser call 77 ; via la TAS (écriture) ld hl,6912 ; on récupère la coord Y de la fusée call 74 ; via la TAS (lecture) sub 17 ; enlève 17 à Y pour que le laser=tête de la fusée ld hl,6920 ; et on la met sa valeur dans le Y du laser call 77 ; via la TAS (écriture) ld a,0 ; on passe indbal à 0 ld [indbal],a ; pour indiquer qu\u0026rsquo;un tir est en cours ret ; retour à la boucle principale \nTIRBAL Comme on vient de tirer : indbal=0 maintenant\nEt la boucle principale appelle la routine de déplacement de la balle (ou du laser si vous préférez).\nCette routine ne fait que :\n faire appel à une autre routine pour le déplacement (DEPBAL:)\n activer le registre de collision du MSX  Elle appelle donc 3 fois DEPBAL sinon le déplacement d\u0026rsquo;un pixel serait trop lent à l\u0026rsquo;affichage.\nPuis elle active un registre existant du MSX (en VRAM) qui surveille si des SPRITES entrent en collision. Ce registre est consulté via un CALL 318.\nSi parmi les 8 bits qui composent ce registre, le bit 5 est à 1 alors c\u0026rsquo;est qu\u0026rsquo;il y a collision.\nDu coup, on met à jour une variable à nous que l\u0026rsquo;on a appelé indcol et qui nous permettra de déclencher l\u0026rsquo;explosion dans la boucle principale.\nVoici le code : ;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; ; TIRBAL ;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; TIRBAL: call DEPBAL ; appel routine pour déplacer le sprite laser vers le haut call DEPBAL ; opération reproduite 3 fois call DEPBAL ; pour que le laser se déplace très vite call 318 ; rappel du registre des collisions de sprites bit 5,a ; on teste le bit 5 ret z ; si le bit 5=0 alors pas de collision et on quitte ld a,0 ; sinon bit 5=1 collision alors on passe indcol à 0 ld [indcol],a ; ce qui déclenchera une explosion via le boucle principale ret \nDEPBAL Cette routine ne fait que déplacer le sprite laser d\u0026rsquo;un pixel vers le haut et vérifie si le laser est arrivé à lextrémité haute de l\u0026rsquo;écran (Y=0).\nSi c\u0026rsquo;est le cas, il faut que le laser soit réinitialisé, donc caché de l\u0026rsquo;écran et à disposition pour un nouveau tir.\nPour cela on change les coordonnées du sprite laser et on repasse indbal à 1 via une sous-routine HAUT:\nVoici le code :\n;------------------------------------------------------------------------------ ; DEPBAL ;------------------------------------------------------------------------------ DEPBAL: ld hl,6920 ; on récupère le Y du laser call 74 ; via la TAS (lecture) dec a ; on décrémente Y pour que le laser monte jp z,HAUT ; si Y=0 alors appel routine HAUT: call 77 ; sinon on charge la nouvelle valeur dans la TAS ret HAUT: ld a,200 ; on met la valeur 200 dans le Y du laser ld hl,6920 ; le sprite sera en attente en dehors de l'écran call 77 ; via la TAS (écriture) ld a,1 ; et on passe indbal à 1 ld [indbal],a ; ainsi on autorise on nouveau déclenchement de laser ret  EXPLO La boucle principale teste à chaque fois si indcol=0 (une collision a eu lieu). Elle appelle alors la routine EXPLO:i qui va produire une explosion.\nLe mode écran est tout d\u0026rsquo;abord réinitialisé en mode 3 (multicouleur), les tables de la VRAM sont remplies avec des valeurs aléatoires qui affichera des carrés de toutes les couleurs, ce processus est appelé plusieurs fois et la routine finie par appeller la routine DEBUT: qui fait recommencer le jeu avec des variables remises à 1.\net voici : ;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; ; EXPLO ;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; EXPLO: ld a,3 ; 3 pour screen 3 ld [64687],a ; (bios)SCRMOD adresse hexa $FCAF :mode courant de l\u0026rsquo;écran call 95 ; (bios) CHGMOD change le mode de l\u0026rsquo;écran ld a,100 ; valeurs de départ ld hl,0\nEXPLO1: PUSH hl PUSH af ld de,2048 ld bc,1000 call 92 pop af pop hl inc h dec a jp nz,EXPLO1 jp DEBUT \nIl ne nous reste plus qu\u0026rsquo;à compléter la boucle principale pour tester la touche espace (lignes 27 à 30 du code ci-dessous) et tester les variables (lignes 10 à 17 du code ci-dessous).\nBOUCLE PRINCIPALE  ;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; ; Boucle du jeu : Le programme démarre à DEBUT puis va à BOUCLE ;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\nDEBUT: ; c\u0026rsquo;est ici que débute le programme !!! call INIT ; on appelle le sous-prog INIT BOUCLE: ; c\u0026rsquo;est la boucle principale du programme !!! call DEPENV ; on appelle le déplacement de l\u0026rsquo;envahisseur call DELAI ; on appelle le sous-prog DELAI afin de ralentir l\u0026rsquo;exécution ld a,[indcol] ; on charge la valeur de indcol dans a inc a ; on fait un calcul sur a dec a jp z,EXPLO ; si a=0 alors on appelle EXPLO ld a,[indbal] ; on charge la valeur de indbal dans a inc a ; on fait un calcul sur a dec a call z,TIRBAL ; si a=0 alors on appelle TIRBAL ld a,8 ; on teste la touche gauche = ligne 8 de la matrice du clavier call 321 ; (bios) SNSMAT retourne dans la valeur de la ligne 8 bit 4,a ; bit teste la colonne 4 (0=pressé 1=non pressé) call z,FUSGAU ; si résultat=0 on va au sous-prog FUSGAU (déplacer à droite) call DELAI ; on ralenti l\u0026rsquo;exécution ld a,8 ; la touche droite est aussi sur la ligne 8 de la matrice call 321 ; on appelle le bios pour qu\u0026rsquo;il donne la valeur de la ligne 8 bit 7,a ; la colonne 7 est testée (0=pressé 1=non pressé) call z,FUSDRO ; si résultat=0 on va au sous-prog FUSDRO (déplacer àgauche) ld a,8 ; on teste la touche espace=ligne 8 de la matrice du clavier call 321 ; on appelle le bios pour qu\u0026rsquo;il donne la valeur de la ligne 8 bit 0,a ; la colonne 0 est testée (0=pressée) call z,FEU ; si résultat=0 on va au sous-prog FEU (déclenchement laser) call DELAI ; on ralenti l\u0026rsquo;exécution jp BOUCLE ; on redémarre la boucle principale \nComme d\u0026rsquo;habitude je vous donne le code final mis à jour à compiler et à vérifier avec votre émulateur :\n; **************************************************************** ; MSX ROM Cartridge Header and Function library ; **************************************************************** FNAME \"test4.ROM\" cpu z80 ORG 4000h INCLUDE \"MSXRom-Include.asm\" db \"AB\" DW DEBUT ; la ROM lance le sous-programme DEBUT au démarrage DW 0 DW 0 DW 0 DS 6 ;------------------------------------------------------------------------------ ; Iinitialisation, appelé par le début du programme : DEBUT ;------------------------------------------------------------------------------ INIT: Ld a,1 ; 1 pour screen 1 ld [64687],a ; (bios)SCRMOD adresse hexa $FCAF :mode courant de l'ecran call 95 ; (bios)CHGMOD : change le mode l'écran ;------------------------------------------------------------------------------ ; Charge la TGS avec la forme des 3 sprites ;------------------------------------------------------------------------------ ld hl,donnee ; charge les données TGS via le label: donnee ld de,14336 ; adresse du début de la TGS ld bc,24 ; longueur du bloc = 3 sprites de 8 octets = 24 call 92 ; LIDRVM transfert de bloc de la RAM vers la VRAM ;------------------------------------------------------------------------------ ; Charge la TAS avec les attributs des 3 sprites (registre 5) ; Registre 5 =\u0026gt; valeur x 128 = Début de l'adresse de la TAS ;------------------------------------------------------------------------------ ld c,5 ; registre 5 gère l'adresse de début de la TAS ld b,54 ; valeur 54 = positionne début de la TAS à l'adresse 6912 call 71 ; WRTVDP Ecrire dans le VDP (VRAM) ld hl,donne1 ; charge les données TAS au label: donne1 ld de,6912 ; adresse du début de la TAS ld bc,12 ; longueur du bloc = 4 données pour chaque sprite (3 sprites) call 92 ; LIDRVM transfert de bloc de la RAM vers la VRAM ;------------------------------------------------------------------------------ ; Initialise les 3 variables  ; indcol: indicateur de collision adresse 41000 ; indbal: indicateur de balle tirée adresse 41001 ; inddir: indicateur de direction de l'ennemi adresse 41002 ;------------------------------------------------------------------------------ ld a,1 ld [indcol],a ; indcol = 1 ld [indbal],a ; indbal = 1 ld [inddir],a ; inddir = 1 ;------------------------------------------------------------------------------ ; Taille des sprites agrandis (registre 1) ;------------------------------------------------------------------------------ ld c,1 ; registre 1 gère la taille des sprites ld b,225 ; 225 c'est la valeur pour agrandir un sprite 8 x 8 call 71 ; WRTVDP Ecrire dans un registre du VDP (VRAM) ;------------------------------------------------------------------------------ ; Positionne l'adresse de début de la TNP (registre 2) ; Registre 2 =\u0026gt; valeur x 1024 = Début de l'adresse de la TNP ;------------------------------------------------------------------------------ ld c,2 ; registre 2 ld b,6 ; valeur 6 = positionne début de la TNP à l'adresse 6144 call 71 ; WRTVDP Ecrire dans un registre du VDP (VRAM) ret ; fin de la boucle INIT ;------------------------------------------------------------------------------ ; Déplacement de la fusée à gauche ;------------------------------------------------------------------------------ FUSGAU: ld hl,6913 ; récupère adresse de la position x du sprite dans la TAS call 74 ; la fonction charge la valeur de l'adresse dans A donc x=A dec a ; on teste A en le décrementant d'une unité x-1 ret z ; si le résultat de l'opération x=0 on ne fait rien ; et on quitte la sous-routine ; car cela veut dire que la fusée est à la limite de l'écran à gauche call 77 ; sinon on charge la position x de la TAS avec la nouvelle valeur x-1 ret ; on retourne au programme principal ;------------------------------------------------------------------------------ ; Déplacement de la fusée droite ;------------------------------------------------------------------------------ FUSDRO: ld hl,6913 ; récupère adresse de la position x du sprite dans la TAS call 74 ; la fonction charge la valeur de l'adresse dans A donc x=A SUB 240 ; on teste A en lui enlevant 240 ret z ; si le résultat de l'opération=0 on ne fait rien  ; et on quitte la sous-routine ; car cela veut dire que la fusée est à la limite de l'écran à droite add a,241 ; rajoute les 240 pour retrouver le x initial et incrémente de 1(donc 241) call 77 ; sinon on charge la position x de la TAS avec la nouvelle valeur x+1 ret ; on retourne au programme principal ;------------------------------------------------------------------------------ ; DELAI ;------------------------------------------------------------------------------ DELAI: ld a,255 ; c'est la valeur de départ, plus elles est haute, plus c'est lent ; a ne peut contenir qu'une valeur entre 0 et 255 DEL: dec a ; c'est la boucle qui va décrémenter de 1 jusqu'à a=0 jp nz,DEL ; si a n'est pas égale à 0 on repart au début de la boucle ret ; si a=0 on retourne au programme principal ;------------------------------------------------------------------------------ ; Déplacement de l'envahisseur / Gestion de la direction de l'envahisseur ; indir=1 : de droite à gauche / indir=0 : de gauche à droite ;------------------------------------------------------------------------------ DEPENV: ld a,[inddir] ; on charge en a la valeur de l'indicateur de direction dec a ; on décremente a pour vérifier si indir=1 jp z,ENGAU ; si a=0 c'est que indir valait 1,on va au sous-prog ENGAU (à gauche) ld hl,6917 ; sinon on récupère adresse de la position x du sprite dans la TAS call 74 ; la fonction récupère la valeur de l'adresse dans A donc x=A sub 240 ; on elève 240 à a jp nz,ENDRO1 ; si le résultat n'égale pas 0 alors on va en ENDRO1 (à droite) ld a,1 ; sinon on est au bord droit de l'écran et on change l'indicateur ld [inddir],a ; on charge l'indicateur avec la nouvelle direction (1) ret ;------------------------------------------------------------------------------ ; Déplacement de l'envahisseur vers la droite ;------------------------------------------------------------------------------ ENDRO1: ld hl,6917 ; on récupère adresse de la position x du sprite dans la TAS call 74 ; la fonction récupère la valeur de l'adresse dans A donc x=A inc a ; on incrémente a pour déplacer de 1 à droite (x+1) call 77 ; on charge la position x de la TAS avec le x+1 ret ; on retourne au programme principal ;------------------------------------------------------------------------------ ; Changement de direction (0) si l'envahisseur est arrivé au bord gauche x=0 ;------------------------------------------------------------------------------ ENGAU: ld hl,6917 ; on récupère adresse de la position x du sprite dans la TAS call 74 ; la fonction récupère la valeur de l'adresse dans A donc x=A SUB 1 ; on enlève 1 à a (x-1) jp nz,ENGAU1 ; si maintenant n'est pas égale à 0 on va en ENGAU1 ld a,0 ; sinon on est au bord gauche de l'écran et on change l'indicateur ld [inddir],a ; on charge l'indicateur avec la nouvelle direction (0) ret ;------------------------------------------------------------------------------ ; Déplacement de l'envahisseur vers la gauche ;------------------------------------------------------------------------------ ENGAU1: ld hl,6917 ; on récupère adresse de la position x du sprite dans la TAS call 74 ; la fonction récupère la valeur de l'adresse dans A donc x=A dec a ; on décrémente a pour déplacer de 1 à gauche (x-1) call 77 ; on charge la position x de la TAS avec le x+1 ret ; on retourne au programme principal ;------------------------------------------------------------------------------ ; FEU ; indbal=1 pas de balle tirée / indbal=0 balle tirée ;------------------------------------------------------------------------------ FEU: ld a,[indbal] ; on vérifie la valeur de indbal inc a ; si indbal=0 une balle est déjà en cours dec a ; donc on ne peut pas retirer ret z ; et on quitte la routine ld hl,6913 ; si indbal=1 on récupère la coord X de la fusée call 74 ; via la TAS (lecture) ld hl,6921 ; et on la met sa valeur dans le X du laser call 77 ; via la TAS (écriture) ld hl,6912 ; on récupère la coord Y de la fusée call 74 ; via la TAS (lecture) sub 17 ; enlève 17 à Y pour que le laser=tête de la fusée ld hl,6920 ; et on la met sa valeur dans le Y du laser call 77 ; via la TAS (écriture) ld a,0 ; on passe indbal à 0 ld [indbal],a ; pour indiquer qu'un tir est en cours ret ; retour à la boucle principale ;------------------------------------------------------------------------------ ; DEPBAL ;------------------------------------------------------------------------------ DEPBAL: ld hl,6920 ; on récupère le Y du laser call 74 ; via la TAS (lecture) dec a ; on décrémente Y pour que le laser monte jp z,HAUT ; si Y=0 alors appel routine HAUT: call 77 ; sinon on charge la nouvelle valeur dans la TAS ret HAUT: ld a,200 ; on met la valeur 200 dans le Y du laser ld hl,6920 ; le sprite sera en attente en dehors de l'écran call 77 ; via la TAS (écriture) ld a,1 ; et on passe indbal à 1 ld [indbal],a ; ainsi on autorise on nouveau déclenchement de laser ret ;------------------------------------------------------------------------------ ; TIRBAL ;------------------------------------------------------------------------------ TIRBAL: call DEPBAL ; appel routine pour déplacer le sprite laser vers le haut call DEPBAL ; opération reproduite 3 fois call DEPBAL ; pour que le laser se déplace très vite call 318 ; rappel du registre des collisions de sprites bit 5,a ; on teste le bit 5 ret z ; si le bit 5=0 alors pas de collision et on quitte ld a,0 ; sinon bit 5=1 collision alors on passe indcol à 0 ld [indcol],a ; ce qui déclenchera une explosion via le boucle principale ret ;------------------------------------------------------------------------------ ; EXPLO ;------------------------------------------------------------------------------ EXPLO: ld a,3 ; 3 pour screen 3 ld [64687],a ; (bios)SCRMOD adresse hexa $FCAF :mode courant de l'écran call 95 ; (bios) CHGMOD change le mode de l'écran ld a,100 ; valeurs de départ ld hl,0 EXPLO1: PUSH hl PUSH af ld de,2048 ld bc,1000 call 92 pop af pop hl inc h dec a jp nz,EXPLO1 jp DEBUT ;------------------------------------------------------------------------------ ; Boucle du jeu : Le programme démarre à DEBUT puis va à BOUCLE ;------------------------------------------------------------------------------ DEBUT: ; c'est ici que débute le programme !!! call INIT ; on appelle le sous-prog INIT BOUCLE: ; c'est la boucle principale du programme !!! call DEPENV ; on appelle le déplacement de l'envahisseur call DELAI ; on appelle le sous-prog DELAI afin de ralentir l'exécution ld a,[indcol] ; on charge la valeur de indcol dans a inc a ; on fait un calcul sur a dec a jp z,EXPLO ; si a=0 alors on appelle EXPLO ld a,[indbal] ; on charge la valeur de indbal dans a inc a ; on fait un calcul sur a dec a call z,TIRBAL ; si a=0 alors on appelle TIRBAL ld a,8 ; on teste la touche gauche = ligne 8 de la matrice du clavier call 321 ; (bios) SNSMAT retourne dans la valeur de la ligne 8 bit 4,a ; bit teste la colonne 4 (0=pressé 1=non pressé) call z,FUSGAU ; si résultat=0 on va au sous-prog FUSGAU (déplacer à droite) call DELAI ; on ralenti l'exécution ld a,8 ; la touche droite est aussi sur la ligne 8 de la matrice call 321 ; on appelle le bios pour qu'il donne la valeur de la ligne 8 bit 7,a ; la colonne 7 est testée (0=pressé 1=non pressé) call z,FUSDRO ; si résultat=0 on va au sous-prog FUSDRO (déplacer àgauche) ld a,8 ; on teste la touche espace=ligne 8 de la matrice du clavier call 321 ; on appelle le bios pour qu'il donne la valeur de la ligne 8 bit 0,a ; la colonne 0 est testée (0=pressée) call z,FEU ; si résultat=0 on va au sous-prog FEU (déclenchement laser) call DELAI ; on ralenti l'exécution jp BOUCLE ; on redémarre la boucle principale ;------------------------------------------------------------------------------ ; Les données ;------------------------------------------------------------------------------ donnee: db 24,24,126,126 ; sprite 1 pour la TGS db 255,255,255,0 ; sprite 1 \" \" db 60,126,153,255 ; sprite 2 \" \" db 102,60,66,36 ; sprite 2 \" \" db 24,24,24,24 ; sprite 3 \" \" db 24,24,24,24 ; sprite 3 \" \" donne1: db 170,100,0,15 ; Attributs du sprite 0 (position x, y,n°sprite,couleur) db 0,0,1,12 ; Attributs du sprite 1 (position x, y,n°sprite,couleur) db 200,0,2,1 ; Attributs du sprite 2 (position x, y,n°sprite,couleur) ;************************************************************************************************** ; Standard Libraries ;************************************************************************************************** INCLUDE \"MSXRom-Lib.asm\" ; intègre la librairie MSX END: EQU $ indcol: EQU 41000 ; défini l'adresse de la variable indcol (registre des collisions) indbal: EQU 41001 ; défini l'adresse de la variable indbal inddir: EQU 41002 ; défini l'adresse de la variable inddir ;************************************************************************************************** ; RAM Definitions ;************************************************************************************************** ;------------------- ; Définit que le programme démarrera au début de la RAM disponible ;------------------- ORG RAMSTART  "
},
{
	"uri": "/tuto-asm-01/12/12-fin/",
	"title": "12-Fin du tutoriel",
	"tags": [],
	"description": "",
	"content": " SHOOT \u0026lsquo;EM UP Comme son titre l\u0026rsquo;indique, on est parvenu à la fin du tutoriel.\nLe but était de faire une initiation de l\u0026rsquo;assembleur MSX, les routines sont simples, le code peut-être largement amélioré, mes explications surement aussi.\nMais si cela peut donner des idées à ceux qui ont envie de se lancer, mon objectif sera atteint.\nMon plus grand souhait serait que ceux qui maîtrisent l\u0026rsquo;assembleur sous MSX aient pris connaissance du niveau d\u0026rsquo;explication qui est nécessaire pour des personnes qui souhaitent progresser. Et s\u0026rsquo;ils se lancent dans des tutoriels, qu\u0026rsquo;ils soient rassurés, ils seront lus !\nJusqu\u0026rsquo;à présent j\u0026rsquo;ai eu du mal à trouver ce type d\u0026rsquo;information et des tutoriels français qui soient progressifs dans l\u0026rsquo;apprentissage du développement d\u0026rsquo;un jeu.\n"
},
{
	"uri": "/",
	"title": "Accueil",
	"tags": [],
	"description": "",
	"content": " MSX-coding Code et Documentation de l\u0026rsquo;ordinateur MSX.\n"
},
{
	"uri": "/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/games/",
	"title": "Games",
	"tags": [],
	"description": "",
	"content": " LIZARD WILLY \r\rFichiers associés\r\r\r\r"
},
{
	"uri": "/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]